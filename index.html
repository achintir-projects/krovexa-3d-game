<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced 3D World with Realistic Humans and First-Person Mode</title>
    <!-- PWA: manifest + theme color -->
    <link rel="manifest" href="/manifest.webmanifest">
    <meta name="theme-color" content="#000000">
    <!-- End PWA -->
    <style>
        /* Existing styles remain unchanged */
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #000;
        }
        
        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            max-width: 300px;
            z-index: 100;
            box-shadow: 0 0 15px rgba(255, 0, 0, 0.5);
            border: 1px solid #ff0000;
        }
        
        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            z-index: 100;
            max-width: 300px;
            max-height: 70vh;
            overflow-y: auto;
            box-shadow: 0 0 15px rgba(255, 0, 0, 0.5);
            border: 1px solid #ff0000;
        }
        
        button {
            background-color: #990000;
            border: none;
            color: white;
            padding: 8px 16px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 14px;
            margin: 4px 2px;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.3s;
            box-shadow: 0 0 10px rgba(255, 0, 0, 0.7);
        }
        
        button:hover {
            background-color: #cc0000;
            box-shadow: 0 0 15px rgba(255, 0, 0, 0.9);
            transform: translateY(-2px);
        }
        
        .slider-container {
            margin: 10px 0;
            color: white;
        }
        
        input[type="range"] {
            width: 200px;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            z-index: 200;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 15px rgba(255, 0, 0, 0.5);
            border: 1px solid #ff0000;
        }
        
        .mode-button {
            background-color: #990000;
            box-shadow: 0 0 10px rgba(255, 0, 0, 0.7);
        }
        
        .mode-button.active {
            background-color: #ff0000;
            box-shadow: 0 0 15px rgba(255, 0, 0, 0.9);
        }
        
        #timeDisplay {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 8px;
            z-index: 100;
            box-shadow: 0 0 15px rgba(255, 0, 0, 0.5);
            border: 1px solid #ff0000;
        }
        
        .biome-button {
            background-color: #990000;
            width: 100%;
            margin: 2px 0;
            box-shadow: 0 0 10px rgba(255, 0, 0, 0.7);
        }
        
        .control-section {
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255, 0, 0, 0.3);
            color: white;
        }
        
        .control-section h3 {
            margin-top: 0;
            margin-bottom: 10px;
            color: #ff0000;
        }
        
        #stats {
            position: absolute;
            top: 80px;
            right: 10px;
            color: white;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 8px;
            z-index: 100;
            font-size: 14px;
            box-shadow: 0 0 15px rgba(255, 0, 0, 0.5);
            border: 1px solid #ff0000;
        }
        
        .health-bar-container {
            position: absolute;
            width: 40px;
            height: 4px;
            background-color: rgba(255, 0, 0, 0.3);
            border-radius: 2px;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 10;
        }
        
        .health-bar {
            height: 100%;
            background-color: #ff0000;
            border-radius: 2px;
            width: 100%;
        }
        
        .interaction-indicator {
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 10;
        }
        
        .love-indicator {
            background-color: rgba(255, 105, 180, 0.7);
        }
        
        .hate-indicator {
            background-color: rgba(255, 0, 0, 0.7);
        }
        
        #floodWarning {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #FF5722;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            font-size: 24px;
            font-weight: bold;
            z-index: 150;
            display: none;
            text-align: center;
            box-shadow: 0 0 15px rgba(255, 0, 0, 0.5);
            border: 1px solid #ff0000;
        }
        
        .record-button {
            background-color: #990000;
            box-shadow: 0 0 10px rgba(255, 0, 0, 0.7);
        }
        
        .record-button.active {
            background-color: #ff0000;
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(255, 0, 0, 0.7);
            }
            70% {
                box-shadow: 0 0 0 10px rgba(255, 0, 0, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(255, 0, 0, 0);
            }
        }
        
        #recordingIndicator {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            background-color: rgba(244, 67, 54, 0.8);
            padding: 8px 16px;
            border-radius: 20px;
            z-index: 150;
            display: none;
            font-weight: bold;
            box-shadow: 0 0 15px rgba(255, 0, 0, 0.5);
            border: 1px solid #ff0000;
        }
        
        .recording-dot {
            display: inline-block;
            width: 10px;
            height: 10px;
            background-color: #fff;
            border-radius: 50%;
            margin-right: 8px;
            animation: blink 1s infinite;
        }
        
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
        
        .speech-bubble {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.8);
            border-radius: 10px;
            padding: 8px 12px;
            font-size: 14px;
            color: #ffffff;
            max-width: 150px;
            text-align: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            z-index: 20;
            pointer-events: none;
            border: 1px solid #ff0000;
        }
        
        .speech-bubble:after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            border-width: 10px 10px 0;
            border-style: solid;
            border-color: rgba(0, 0, 0, 0.8) transparent transparent;
        }
        
        .emotion-indicator {
            position: absolute;
            width: 40px;
            height: 40px;
            font-size: 30px;
            text-align: center;
            line-height: 40px;
            z-index: 15;
            pointer-events: none;
            text-shadow: 0 0 10px rgba(255, 0, 0, 0.8);
        }
        
        /* Enter World Mode Styles */
        #enterWorldButton {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #990000;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            z-index: 150;
            box-shadow: 0 0 15px rgba(255, 0, 0, 0.7);
            transition: all 0.3s;
        }
        
        #enterWorldButton:hover {
            background-color: #ff0000;
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.9);
        }
        
        #enterWorldButton.active {
            background-color: #ff0000;
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.9);
        }
        
        #mobileControls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 150;
            display: none;
        }
        
        #joystickContainer {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 150px;
            height: 150px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 50%;
            border: 2px solid #ff0000;
            box-shadow: 0 0 15px rgba(255, 0, 0, 0.5);
        }
        
        #joystick {
            position: absolute;
            width: 50px;
            height: 50px;
            background-color: #ff0000;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.7);
        }
        
        #jumpButton {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 60px;
            height: 60px;
            background-color: #990000;
            border-radius: 50%;
            border: none;
            color: white;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 15px rgba(255, 0, 0, 0.7);
            z-index: 150;
        }
        
        #jumpButton:active {
            background-color: #ff0000;
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.9);
        }
        
        #interactionPrompt {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 16px;
            z-index: 150;
            display: none;
            border: 1px solid #ff0000;
            box-shadow: 0 0 15px rgba(255, 0, 0, 0.5);
        }
        
        #interactionPrompt span {
            color: #ff0000;
            font-weight: bold;
        }
        
        /* Microphone control - FIXED: Now properly positioned in sidebar */
        .microphone-container {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid rgba(255, 0, 0, 0.3);
        }
        
        #microphoneButton {
            background-color: #990000;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            width: 100%;
            box-shadow: 0 0 10px rgba(255, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        #microphoneButton:hover {
            background-color: #cc0000;
            box-shadow: 0 0 15px rgba(255, 0, 0, 0.9);
        }
        
        #microphoneButton.active {
            background-color: #ff0000;
            animation: pulse 1.5s infinite;
        }
        
        /* Performance indicator */
        #performanceIndicator {
            position: absolute;
            bottom: 10px;
            right: 10px;
            color: white;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 150;
        }
        
        /* Touch controls for mobile - FIXED: Now visible on Android */
        #touchControls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 150;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 20px;
        }
        
        #touchJoystick {
            position: relative;
            width: 100px;
            height: 100px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 50%;
            border: 2px solid #ff0000;
            box-shadow: 0 0 15px rgba(255, 0, 0, 0.5);
            touch-action: none;
        }
        
        #touchJoystickKnob {
            position: absolute;
            width: 40px;
            height: 40px;
            background-color: #ff0000;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.7);
        }
        
        #lookControl {
            position: relative;
            width: 150px;
            height: 150px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 50%;
            border: 2px solid #ff0000;
            box-shadow: 0 0 15px rgba(255, 0, 0, 0.5);
            touch-action: none;
        }
        
        #lookControlKnob {
            position: absolute;
            width: 60px;
            height: 60px;
            background-color: #ff0000;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.7);
        }
        
        /* Auto Camera Controls */
        #autoCameraControls {
            position: absolute;
            top: 60px;
            left: 10px;
            color: white;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 8px;
            z-index: 100;
            max-width: 200px;
            box-shadow: 0 0 15px rgba(255, 0, 0, 0.5);
            border: 1px solid #ff0000;
        }
        
        #autoCameraButton {
            background-color: #990000;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            width: 100%;
            margin-bottom: 10px;
            box-shadow: 0 0 10px rgba(255, 0, 0, 0.7);
        }
        
        #autoCameraButton:hover {
            background-color: #cc0000;
            box-shadow: 0 0 15px rgba(255, 0, 0, 0.9);
        }
        
        #autoCameraButton.active {
            background-color: #ff0000;
            box-shadow: 0 0 15px rgba(255, 0, 0, 0.9);
        }
        
        #cameraTargetList {
            max-height: 150px;
            overflow-y: auto;
            margin-top: 10px;
        }
        
        .camera-target-item {
            background-color: rgba(153, 0, 0, 0.7);
            color: white;
            padding: 5px;
            margin: 2px 0;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        
        .camera-target-item:hover {
            background-color: rgba(204, 0, 0, 0.7);
        }
        
        .camera-target-item.active {
            background-color: rgba(255, 0, 0, 0.7);
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="loading">Loading Advanced 3D World with Realistic Humans...</div>
        
        <button id="enterWorldButton">Enter World</button>
        
        <div id="interactionPrompt">Press <span>E</span> to interact</div>
        
        <div id="mobileControls">
            <div id="joystickContainer">
                <div id="joystick"></div>
            </div>
            <button id="jumpButton">↑</button>
        </div>
        
        <!-- Touch controls for mobile -->
        <div id="touchControls">
            <div id="lookControl">
                <div id="lookControlKnob"></div>
            </div>
            <div id="touchJoystick">
                <div id="touchJoystickKnob"></div>
            </div>
        </div>
        
        <div id="info">
            <h3>Advanced 3D World with Realistic Humans</h3>
            <p>Use mouse to orbit around the scene. Scroll to zoom in/out.</p>
            <p>Click on objects to interact with them.</p>
            <p>Drag objects to move them around.</p>
            <p>Humans have emotions, animations, and can interact.</p>
            <p>Rain accumulates water on the ground and can cause flooding.</p>
            <p>Humans can now enter and exit buildings through doors!</p>
            <p>Click "Enter World" for first-person experience!</p>
        </div>
        
        <div id="controls">
            <div class="control-section">
                <h3>Environment Controls</h3>
                <button id="togglePhysics" class="mode-button">Enable Physics</button>
                <button id="toggleRain" class="mode-button">Rain Mode</button>
                <button id="toggleSnow" class="mode-button">Snow Mode</button>
                <button id="toggleDayNight" class="mode-button">Day/Night Cycle</button>
                <button id="resetScene">Reset Scene</button>
                
                <div class="slider-container">
                    <label for="timeSpeedSlider">Day/Night Speed:</label>
                    <input type="range" id="timeSpeedSlider" min="0" max="0.002" step="0.0001" value="0.0005">
                </div>
                <div class="slider-container">
                    <label for="rainIntensitySlider">Rain Intensity:</label>
                    <input type="range" id="rainIntensitySlider" min="0.1" max="1" step="0.1" value="0.5">
                </div>
            </div>
            
            <div class="control-section">
                <h3>Biome Selection</h3>
                <button id="biomeForest" class="biome-button">Forest</button>
                <button id="biomeDesert" class="biome-button">Desert</button>
                <button id="biomeSnow" class="biome-button">Snow</button>
                <button id="biomeJungle" class="biome-button">Jungle</button>
                <button id="biomeVolcano" class="biome-button">Volcano</button>
                <button id="biomeIsland" class="biome-button">Island</button>
                <button id="biomeTown" class="biome-button">Town</button>
                <button id="biomeMaze" class="biome-button">Maze</button>
                <button id="biomeLuxury" class="biome-button">Luxury Houses</button>
            </div>
            
            <div class="control-section">
                <h3>Spawn Objects</h3>
                <button id="addObject">Add Object</button>
                <button id="spawnHuman">Spawn Human</button>
                <button id="spawnGun">Spawn Gun</button>
                <button id="spawnRagdoll">Spawn Ragdoll</button>
                <button id="spawnMultipleHumans">Spawn 5 Humans</button>
                <button id="spawnMultipleGuns">Spawn 5 Guns</button>
            </div>
            
            <div class="control-section">
                <h3>AI Behavior</h3>
                <button id="toggleAggression">Toggle Aggression</button>
                <button id="toggleInteractions">Toggle Interactions</button>
                <button id="toggleSpeech">Toggle Speech</button>
                <div class="slider-container">
                    <label for="aiSpeedSlider">AI Speed:</label>
                    <input type="range" id="aiSpeedSlider" min="0.01" max="0.2" step="0.01" value="0.05">
                </div>
                <div class="slider-container">
                    <label for="cameraSensitivitySlider">Camera Sensitivity:</label>
                    <input type="range" id="cameraSensitivitySlider" min="0.1" max="2" step="0.1" value="1">
                </div>
            </div>
            
            <div class="control-section">
                <h3>Recording</h3>
                <button id="startRecording" class="record-button">Start Recording</button>
                <button id="stopRecording" class="record-button" disabled>Stop Recording</button>
                <button id="downloadVideo" disabled>Download Video</button>
                
                <div class="slider-container">
                    <label for="timelapseSpeedSlider">Timelapse Speed:</label>
                    <input type="range" id="timelapseSpeedSlider" min="1" max="60" step="1" value="10">
                    <span id="timelapseSpeedValue">10x</span>
                </div>
                
                <div class="slider-container">
                    <label for="videoQualitySlider">Video Quality:</label>
                    <input type="range" id="videoQualitySlider" min="0.1" max="1" step="0.1" value="0.7">
                    <span id="videoQualityValue">70%</span>
                </div>
                
                <div class="slider-container">
                    <label for="microphoneVolumeSlider">Microphone Volume:</label>
                    <input type="range" id="microphoneVolumeSlider" min="0" max="1" step="0.1" value="0.7">
                    <span id="microphoneVolumeValue">70%</span>
                </div>
            </div>
            
            <!-- FIXED: Microphone button moved to recording section in sidebar -->
            <div class="control-section">
                <h3>Audio Recording</h3>
                <div class="microphone-container">
                    <button id="microphoneButton">🎤 Toggle Microphone</button>
                    <p style="margin-top: 5px; font-size: 12px;">Toggle microphone to record audio in videos</p>
                </div>
            </div>
        </div>
        
        <div id="autoCameraControls">
            <h3>Auto Camera</h3>
            <button id="autoCameraButton">Enable Auto Camera</button>
            <div id="cameraTargetList"></div>
        </div>
        
        <div id="timeDisplay">
            <div>Time: <span id="currentTime">12:00</span></div>
            <div>Mode: <span id="currentMode">Normal</span></div>
            <div>Biome: <span id="currentBiome">Forest</span></div>
        </div>
        
        <div id="stats">
            <div>Humans: <span id="humanCount">0</span></div>
            <div>Guns: <span id="gunCount">0</span></div>
            <div>Armed Humans: <span id="armedCount">0</span></div>
            <div>Ragdolls: <span id="ragdollCount">0</span></div>
            <div>Water Level: <span id="waterLevel">0</span>%</div>
            <div>AI Aggression: <span id="aggressionLevel">Normal</span></div>
            <div>Recording: <span id="recordingStatus">Not Recording</span></div>
        </div>
        
        <div id="floodWarning">
            ⚠️ FLOOD WARNING ⚠️<br>
            Water level is critical!
        </div>
        
        <div id="recordingIndicator">
            <span class="recording-dot"></span>
            <span id="recordingTime">00:00</span>
        </div>
        
        <div id="performanceIndicator">
            FPS: <span id="fps">0</span>
        </div>
    </div>
    <!-- Three.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- OrbitControls for camera movement -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <!-- Cannon.js for physics -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    
    <script>
        // Global variables
        let scene, camera, renderer, controls;
        let light, ambientLight, hemisphereLight;
        let objects = [];
        let raycaster, mouse;
        
        // Physics variables
        let world, physicsObjects = [];
        let isPhysicsEnabled = false;
        
        // Weather variables
        let rainParticles, snowParticles;
        let isRaining = false;
        let isSnowing = false;
        let wetMaterials = [];
        let snowOnGround = [];
        let waterPatches = [];
        let rainIntensity = 0.5;
        let waterLevel = 0;
        let maxWaterLevel = 100;
        let floodWarningShown = false;
        let rainDrops = []; // Array to store individual rain drops
        let wetSpots = []; // Array to store wet spots on surfaces
        
        // Day/Night cycle variables
        let isDayNightCycle = false;
        let dayNightSpeed = 0.0005;
        let currentTime = 12; // Start at noon
        let sun, moon, stars;
        let clouds = [];
        
        // Biome variables
        let currentBiome = 'forest';
        let ground;
        let grassBlades = []; // Array to store grass blades
        
        // Dragging variables
        let isDragging = false;
        let dragObject = null;
        let dragConstraint = null;
        let draggedRagdollPart = null;
        
        // AI Humans
        let aiHumans = [];
        let aiSpeed = 0.05;
        let aiAggression = true; // Whether AI will attack each other
        let aiInteractions = true; // Whether AI will interact with each other
        let aiSpeech = true; // Whether AI will speak
        
        // Guns
        let guns = [];
        let bullets = [];
        
        // Ragdolls
        let ragdolls = [];
        
        // Health bars container
        let healthBarsContainer;
        
        // Water system variables
        let waterGridSize = 5; // Size of each water patch
        let waterGrid = {}; // Grid to track water levels
        let waterMeshes = []; // Visual water meshes
        
        // Recording variables
        let mediaRecorder;
        let recordedChunks = [];
        let isRecording = false;
        let recordingStartTime;
        let recordingTimer;
        let timelapseSpeed = 10; // Default timelapse speed
        let videoQuality = 0.7; // Default video quality
        let frameCaptureInterval;
        let canvasStream;
        let recordingCanvas;
        let recordingContext;
        
        // Maze variables
        let mazeWalls = [];
        let mazeSize = 15;
        let cellSize = 5;
        
        // Enter World Mode variables
        let isFirstPersonMode = false;
        let firstPersonControls = {
            moveForward: false,
            moveBackward: false,
            moveLeft: false,
            moveRight: false,
            canJump: false,
            velocity: new THREE.Vector3(),
            direction: new THREE.Vector3()
        };
        let player = {
            height: 1.7,
            speed: 5, // Increased speed for better control
            jumpSpeed: 0.3,
            isOnGround: false
        };
        let playerBody;
        let isMobile = false;
        let joystickActive = false;
        let joystickVector = { x: 0, y: 0 };
        let cameraSensitivity = 1.0;
        let lookControls = {
            x: 0,
            y: 0,
            active: false
        };
        
        // Mouse look variables
        let isPointerLocked = false;
        let previousMousePosition = {
            x: 0,
            y: 0
        };
        
        // Microphone variables
        let microphoneStream = null;
        let microphoneEnabled = false;
        let microphoneVolume = 0.7;
        
        // Performance variables
        let lastTime = performance.now();
        let fps = 0;
        let frameCount = 0;
        let fpsUpdateTime = 0;
        
        // Graphics quality variables
        let graphicsQuality = {
            pixelRatio: window.devicePixelRatio,
            antialias: true,
            shadowMapEnabled: true,
            shadowMapType: THREE.PCFSoftShadowMap,
            textureQuality: 'high' // low, medium, high, ultra
        };
        
        // Auto Camera variables
        let autoCameraEnabled = false;
        let cameraTarget = null;
        let cameraTargets = [];
        let cameraOffset = new THREE.Vector3(0, 5, 10);
        
        // Human model assets
        const skinTones = [
            0xFDBCB4, // Light
            0xF1C27D, // Light-medium
            0xE0AC69, // Medium
            0xC68642, // Medium-dark
            0x8D5524  // Dark
        ];
        
        const hairStyles = [
            'short', 'medium', 'long', 'curly', 'bald', 'ponytail', 'braids', 'afro', 
            'mohawk', 'buzzcut', 'undercut', 'bob', 'pixie', 'dreadlocks', 'waves', 'straight'
        ];
        
        const hairColors = [
            0x000000, // Black
            0x4B3621, // Brown
            0x8B4513, // Saddle brown
            0xD2B48C, // Tan
            0xFFD700, // Blonde
            0xFF4500, // Red
            0xFFFFFF,  // White
            0x808080,  // Gray
            0xFFA500,  // Orange
            0x8A2BE2   // Blue-violet
        ];
        
        const clothingStyles = [
            'casual', 'formal', 'sporty', 'business', 'punk', 'bohemian', 'preppy', 'military'
        ];
        
        const clothingColors = [
            0xFF0000, // Red
            0x00FF00, // Green
            0x0000FF, // Blue
            0xFFFF00, // Yellow
            0xFF00FF, // Magenta
            0x00FFFF, // Cyan
            0xFFA500, // Orange
            0x800080, // Purple
            0x008000, // Dark green
            0x000080, // Navy
            0x800000, // Maroon
            0x808000  // Olive
        ];
        
        const jacketColors = [
            0x000080, // Navy blue
            0x2F4F4F, // Dark slate gray
            0x800000, // Maroon
            0x008000, // Green
            0x000000, // Black
            0x8B4513, // Saddle brown
            0x191970, // Midnight blue
            0x556B2F  // Dark olive green
        ];
        
        const emotions = [
            { name: 'happy', emoji: '😊', color: 0xFFD700 },
            { name: 'sad', emoji: '😢', color: 0x1E90FF },
            { name: 'angry', emoji: '😠', color: 0xFF4500 },
            { name: 'surprised', emoji: '😲', color: 0xFF69B4 },
            { name: 'neutral', emoji: '😐', color: 0x808080 },
            { name: 'love', emoji: '😍', color: 0xFF1493 },
            { name: 'laughing', emoji: '😂', color: 0x32CD32 },
            { name: 'confused', emoji: '😕', color: 0x9370DB },
            { name: 'tired', emoji: '😴', color: 0x4682B4 },
            { name: 'excited', emoji: '🤩', color: 0xFF6347 },
            { name: 'hungry', emoji: '🤤', color: 0xFF8C00 },
            { name: 'thirsty', emoji: '🥵', color: 0xFF4500 },
            { name: 'sleepy', emoji: '😪', color: 0x4169E1 },
            { name: 'bored', emoji: '🙄', color: 0x9370DB },
            { name: 'scared', emoji: '😨', color: 0x4B0082 },
            { name: 'sick', emoji: '🤒', color: 0x32CD32 },
            { name: 'cool', emoji: '😎', color: 0x1E90FF },
            { name: 'naughty', emoji: '😈', color: 0x8B0000 },
            { name: 'angel', emoji: '😇', color: 0xFFD700 },
            { name: 'party', emoji: '🥳', color: 0xFF69B4 },
            { name: 'robot', emoji: '🤖', color: 0x708090 }
        ];
        
        const speechPhrases = {
            happy: [
                "Life is good! 😊",
                "What a beautiful day! ☀️",
                "I'm so happy right now! 🎉",
                "Everything is awesome! ✨",
                "Feeling great today! 😄",
                "Love this place! 💖",
                "So much joy in my heart! ❤️",
                "I could dance all day! 💃",
                "This is the best! 🌟",
                "Smiling from ear to ear! 😁"
            ],
            sad: [
                "I'm feeling down today... 😢",
                "Why does everything go wrong? 😔",
                "I need a hug... 🤗",
                "Life can be so hard... 💔",
                "Feeling blue... 💙",
                "Need some cheering up... 🌧️",
                "Tears are falling... 💧",
                "My heart is heavy... 💔",
                "Wish I was somewhere else... 🌍",
                "Just need some time alone... 🕰️"
            ],
            angry: [
                "I can't believe this! 😠",
                "This makes me so mad! 🔥",
                "I need to calm down... 😤",
                "Why does this always happen?! 🤬",
                "So frustrated right now! 😡",
                "Don't make me angry! 💢",
                "I'm seeing red! 🔴",
                "This is unacceptable! ❌",
                "I've had enough! 🛑",
                "My blood is boiling! 🌡️"
            ],
            surprised: [
                "Wow! I didn't expect that! 😲",
                "That's amazing! 🤩",
                "I'm speechless! 😮",
                "What a surprise! 🎁",
                "No way! 🤯",
                "Unbelievable! 😱",
                "My jaw is on the floor! 😲",
                "That blew my mind! 💥",
                "I'm in shock! ⚡",
                "Who could have predicted? 🤔"
            ],
            neutral: [
                "Just another day... 😐",
                "Nothing special happening. 🤷‍♂️",
                "I'm just thinking... 🤔",
                "What should I do now? 🤷‍♀️",
                "Contemplating life... 💭",
                "Just minding my business. 🙇‍♂️",
                "Same old, same old. 🔄",
                "Nothing new under the sun. ☀️",
                "Taking it one step at a time. 👣",
                "Going with the flow. 🌊"
            ],
            love: [
                "I'm in love! ❤️",
                "You're amazing! 💕",
                "I cherish you! 💖",
                "You make my heart flutter! 💓",
                "Love is in the air! 💑",
                "You're my everything! 💗",
                "My heart beats for you! 💗",
                "You complete me! 🧩",
                "Together forever! 💑",
                "You're my sunshine! ☀️"
            ],
            laughing: [
                "That's hilarious! 😂",
                "I can't stop laughing! 🤣",
                "This is too funny! 😹",
                "My sides hurt from laughing! 😆",
                "LOL! 😹",
                "Cracking up! 😂",
                "That's comedy gold! 🏆",
                "I'm dying of laughter! 💀",
                "Too funny! 😂",
                "That made my day! 🌞"
            ],
            confused: [
                "I'm so confused... 😕",
                "What's going on? 🤔",
                "I don't understand... ❓",
                "This doesn't make sense... 🤷‍♂️",
                "My head is spinning! 🌀",
                "Need to figure this out... 🧩",
                "I'm lost... 🗺️",
                "Can someone explain? 🙋‍♂️",
                "This is puzzling... 🧩",
                "I'm in a maze of thoughts! 🌐"
            ],
            tired: [
                "I'm so exhausted... 😴",
                "Need to get some sleep... 😪",
                "Running on empty... ⛽",
                "Time for a nap... 🛏️",
                "So sleepy... 💤",
                "Need more coffee! ☕",
                "I'm running out of energy! 🔋",
                "My eyes are heavy! 👁️",
                "I need to recharge! 🔌",
                "Barely keeping my eyes open! 👀"
            ],
            excited: [
                "I'm so excited! 🤩",
                "Can't wait! 🎉",
                "This is going to be amazing! ✨",
                "Full of energy! ⚡",
                "Ready for adventure! 🗺️",
                "Let's do this! 💪",
                "I'm buzzing with excitement! 🐝",
                "This is going to be epic! 🎬",
                "I'm on cloud nine! ☁️",
                "Let the fun begin! 🎪"
            ],
            hungry: [
                "I'm starving! 🍽️",
                "Need food now! 🍔",
                "My stomach is growling! 🐯",
                "Time to eat! 🍴",
                "What's for dinner? 🍲",
                "I could eat a horse! 🐎",
                "Food is on my mind! 🧠",
                "I'm famished! 🍽️",
                "Need some snacks! 🍿",
                "My tummy is rumbling! 🥁"
            ],
            thirsty: [
                "I'm so thirsty! 🥵",
                "Need water! 💧",
                "My throat is dry! 🏜️",
                "Time for a drink! 🍹",
                "I'm dehydrated! 🏜️",
                "Need something cold! ❄️",
                "My mouth is like cotton! 🌬️",
                "I need hydration! 💧",
                "Thirsty as can be! 🏜️",
                "Water, please! 💧"
            ],
            sleepy: [
                "I'm so sleepy... 😴",
                "Time for bed! 🛏️",
                "Need some shut-eye! 👁️",
                "I'm dozing off... 💤",
                "So tired... 😪",
                "Need to rest! 😴",
                "I'm out of energy! 🔋",
                "Time to hit the hay! 🌾",
                "I need some Z's! 💤",
                "My eyelids are heavy! 👁️"
            ],
            bored: [
                "I'm so bored... 🙄",
                "Nothing to do... 🤷‍♂️",
                "This is dull... 😑",
                "Need some excitement! 🎆",
                "I'm bored out of my mind! 🧠",
                "Same old routine... 🔄",
                "I need a change! 🔄",
                "This is so tedious! 😒",
                "I'm counting the minutes! ⏱️",
                "I'm in a rut! 🕳️"
            ],
            scared: [
                "I'm so scared! 😨",
                "This is frightening! 👻",
                "I'm terrified! 😱",
                "My heart is pounding! 💓",
                "I'm shaking! 🥶",
                "This is spooky! 🎃",
                "I'm jumping at shadows! 👥",
                "I'm on edge! ⚡",
                "This is giving me chills! ❄️",
                "I'm trembling! 🥶"
            ],
            sick: [
                "I'm not feeling well... 🤒",
                "I think I'm sick... 🤢",
                "Need a doctor! 👨‍⚕️",
                "I'm under the weather... 🌧️",
                "I feel terrible! 😷",
                "I need medicine! 💊",
                "I'm contagious! 🦠",
                "I'm in pain! 😣",
                "I need to rest! 😴",
                "I'm not myself today! 🤧"
            ],
            cool: [
                "I'm so cool! 😎",
                "Look at me! 😎",
                "I've got style! 🕶️",
                "I'm the coolest! ❄️",
                "I'm too cool for school! 🎒",
                "I'm chillin'! ❄️",
                "I'm the boss! 👑",
                "I'm on top of the world! 🌎",
                "I'm unstoppable! 💪",
                "I'm ice cold! 🧊"
            ],
            naughty: [
                "I'm feeling naughty! 😈",
                "Who's up for trouble? 😉",
                "Let's break some rules! 🚫",
                "I'm a little devil! 😈",
                "Who wants to misbehave? 😏",
                "I'm in a rebellious mood! 🤘",
                "Let's have some fun! 🎉",
                "I'm feeling wicked! 😈",
                "Who's with me? 👉",
                "Let's cause some chaos! 💥"
            ],
            angel: [
                "I'm an angel! 😇",
                "I'm so innocent! 👼",
                "I'm pure of heart! ❤️",
                "I'm a good person! 👍",
                "I'm heaven-sent! ☁️",
                "I'm a saint! ⛪",
                "I'm so good! 👼",
                "I'm a blessing! 🙏",
                "I'm a ray of sunshine! ☀️",
                "I'm a gift from above! 🎁"
            ],
            party: [
                "Let's party! 🥳",
                "I'm ready to celebrate! 🎉",
                "Time to have fun! 🎊",
                "I'm in a party mood! 🎉",
                "Let's dance! 💃",
                "I'm ready to rock! 🎸",
                "I'm feeling festive! 🎊",
                "I'm the life of the party! 🎉",
                "I'm ready to celebrate! 🎊",
                "I'm in the mood to party! 🎉"
            ],
            robot: [
                "Beep boop! 🤖",
                "I am a robot! 🤖",
                "Processing... 💻",
                "Error 404! ❌",
                "System overload! ⚠️",
                "I am not human! 🤖",
                "I am machine! ⚙️",
                "Beep beep! 🚗",
                "I am programmed! 💾",
                "I am AI! 🧠"
            ]
        };
        
        // Initialize the 3D scene
        function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Sky blue for daytime
            
            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 10, 20);
            
            // Create renderer with improved graphics quality
            renderer = new THREE.WebGLRenderer({ 
                antialias: graphicsQuality.antialias,
                preserveDrawingBuffer: true
            });
            
            // Set pixel ratio for better quality
            renderer.setPixelRatio(graphicsQuality.pixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            // Enable shadows with improved quality
            renderer.shadowMap.enabled = graphicsQuality.shadowMapEnabled;
            renderer.shadowMap.type = graphicsQuality.shadowMapType;
            
            // Improved tone mapping for better visuals
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            
            // Improved output encoding
            renderer.outputEncoding = THREE.sRGBEncoding;
            
            document.getElementById('container').appendChild(renderer.domElement);
            
            // Create health bars container
            healthBarsContainer = document.createElement('div');
            healthBarsContainer.style.position = 'absolute';
            healthBarsContainer.style.top = '0';
            healthBarsContainer.style.left = '0';
            healthBarsContainer.style.width = '100%';
            healthBarsContainer.style.height = '100%';
            healthBarsContainer.style.pointerEvents = 'none';
            healthBarsContainer.style.zIndex = '10';
            document.getElementById('container').appendChild(healthBarsContainer);
            
            // Add orbit controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxPolarAngle = Math.PI / 2; // Limit vertical rotation
            
            // Initialize physics world with optimized settings
            world = new CANNON.World();
            world.gravity.set(0, -9.82, 0); // Earth gravity
            world.broadphase = new CANNON.NaiveBroadphase();
            world.solver.iterations = 10;
            world.quatNormalizeFast = true; // For faster physics
            world.quatNormalizeSkip = 0; // For faster physics
            
            // Add lights with improved quality
            ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);
            
            hemisphereLight = new THREE.HemisphereLight(0xffffbb, 0x080820, 0.5);
            scene.add(hemisphereLight);
            
            // Create sun for day/night cycle
            sun = new THREE.DirectionalLight(0xffffff, 1);
            sun.position.set(5, 10, 7);
            sun.castShadow = true;
            sun.shadow.camera.left = -20;
            sun.shadow.camera.right = 20;
            sun.shadow.camera.top = 20;
            sun.shadow.camera.bottom = -20;
            sun.shadow.mapSize.width = 2048; // Higher resolution shadows
            sun.shadow.mapSize.height = 2048;
            sun.shadow.camera.near = 0.5;
            sun.shadow.camera.far = 50;
            scene.add(sun);
            
            // Create moon for night time
            const moonGeometry = new THREE.SphereGeometry(2, 32, 32);
            const moonMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xdddddd,
                emissive: 0x222222,
                shininess: 5
            });
            moon = new THREE.Mesh(moonGeometry, moonMaterial);
            moon.position.set(-30, 30, -30);
            moon.castShadow = true;
            scene.add(moon);
            
            // Create moon light
            const moonLight = new THREE.DirectionalLight(0x8888ff, 0.3);
            moonLight.position.copy(moon.position);
            moonLight.castShadow = true;
            moonLight.shadow.camera.left = -20;
            moonLight.shadow.camera.right = 20;
            moonLight.shadow.camera.top = 20;
            moonLight.shadow.camera.bottom = -20;
            scene.add(moonLight);
            
            // Create stars
            createStars();
            
            // Create clouds
            createClouds();
            
            // Create ground with forest biome by default
            createBiome('forest');
            
            // Create initial objects
            createObjects();
            
            // Initialize raycaster for mouse interaction
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector3();
            
            // Add event listeners
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('mousedown', onMouseDown);
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('mouseup', onMouseUp);
            window.addEventListener('keydown', onKeyDown);
            window.addEventListener('keyup', onKeyUp);
            
            // Setup controls
            setupControls();
            
            // Initialize weather systems
            initWeatherSystems();
            
            // Initialize water grid
            initWaterGrid();
            
            // Initialize recording system
            initRecordingSystem();
            
            // Initialize first-person mode
            initFirstPersonMode();
            
            // Initialize auto camera
            initAutoCamera();
            
            // Initialize microphone
            initMicrophone();
            
            // Check if mobile
            isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            
            // Show mobile controls if on mobile
            if (isMobile) {
                document.getElementById('mobileControls').style.display = 'block';
                document.getElementById('touchControls').style.display = 'flex';
            }
            
            // Hide loading message
            document.getElementById('loading').style.display = 'none';
            
            // Start animation
            animate();
        }
        
        function createStars() {
            const starsGeometry = new THREE.BufferGeometry();
            const starsMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.1,
                transparent: true
            });
            
            const starsVertices = [];
            for (let i = 0; i < 10000; i++) {
                const x = (Math.random() - 0.5) * 2000;
                const y = Math.random() * 500 + 100; // Stars above the horizon
                const z = (Math.random() - 0.5) * 2000;
                starsVertices.push(x, y, z);
            }
            
            starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
            stars = new THREE.Points(starsGeometry, starsMaterial);
            scene.add(stars);
        }
        
        function createClouds() {
            // Create multiple cloud groups
            for (let i = 0; i < 15; i++) {
                const cloudGroup = new THREE.Group();
                
                // Create multiple spheres to form a cloud
                const cloudParts = 5 + Math.floor(Math.random() * 5);
                for (let j = 0; j < cloudParts; j++) {
                    const cloudGeometry = new THREE.SphereGeometry(
                        2 + Math.random() * 3, // Random size
                        8, 6 // Low poly for performance
                    );
                    const cloudMaterial = new THREE.MeshPhongMaterial({
                        color: 0xffffff,
                        transparent: true,
                        opacity: 0.8
                    });
                    
                    const cloudPart = new THREE.Mesh(cloudGeometry, cloudMaterial);
                    
                    // Position cloud parts relative to group center
                    cloudPart.position.set(
                        (Math.random() - 0.5) * 10,
                        Math.random() * 2,
                        (Math.random() - 0.5) * 10
                    );
                    
                    cloudGroup.add(cloudPart);
                }
                
                // Position cloud in the sky
                cloudGroup.position.set(
                    (Math.random() - 0.5) * 200,
                    30 + Math.random() * 30, // Height in the sky
                    (Math.random() - 0.5) * 200
                );
                
                // Store cloud movement speed
                cloudGroup.userData = {
                    speedX: (Math.random() - 0.5) * 0.02,
                    speedZ: (Math.random() - 0.5) * 0.02
                };
                
                scene.add(cloudGroup);
                clouds.push(cloudGroup);
            }
        }
        
        function updateClouds() {
            // Move clouds slowly
            clouds.forEach(cloud => {
                cloud.position.x += cloud.userData.speedX;
                cloud.position.z += cloud.userData.speedZ;
                
                // Wrap clouds around when they go off screen
                if (cloud.position.x > 100) cloud.position.x = -100;
                if (cloud.position.x < -100) cloud.position.x = 100;
                if (cloud.position.z > 100) cloud.position.z = -100;
                if (cloud.position.z < -100) cloud.position.z = 100;
            });
        }
        
        function initFirstPersonMode() {
            // Setup Enter World button
            const enterWorldButton = document.getElementById('enterWorldButton');
            enterWorldButton.addEventListener('click', toggleFirstPersonMode);
            
            // Setup mobile controls
            const joystickContainer = document.getElementById('joystickContainer');
            const joystick = document.getElementById('joystick');
            const jumpButton = document.getElementById('jumpButton');
            
            // Joystick controls
            joystickContainer.addEventListener('touchstart', (e) => {
                e.preventDefault();
                joystickActive = true;
                updateJoystick(e.touches[0]);
            });
            
            joystickContainer.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (joystickActive) {
                    updateJoystick(e.touches[0]);
                }
            });
            
            joystickContainer.addEventListener('touchend', () => {
                joystickActive = false;
                joystick.style.transform = 'translate(-50%, -50%)';
                joystickVector = { x: 0, y: 0 };
            });
            
            // Jump button
            jumpButton.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (isFirstPersonMode && player.isOnGround) {
                    playerBody.velocity.y = player.jumpSpeed;
                    player.isOnGround = false;
                }
            });
            
            // Setup touch controls for mobile
            const touchJoystick = document.getElementById('touchJoystick');
            const touchJoystickKnob = document.getElementById('touchJoystickKnob');
            const lookControl = document.getElementById('lookControl');
            const lookControlKnob = document.getElementById('lookControlKnob');
            
            // Movement joystick
            touchJoystick.addEventListener('touchstart', (e) => {
                e.preventDefault();
                updateTouchJoystick(e.touches[0]);
            });
            
            touchJoystick.addEventListener('touchmove', (e) => {
                e.preventDefault();
                updateTouchJoystick(e.touches[0]);
            });
            
            touchJoystick.addEventListener('touchend', () => {
                touchJoystickKnob.style.transform = 'translate(-50%, -50%)';
                joystickVector = { x: 0, y: 0 };
            });
            
            // Look control
            lookControl.addEventListener('touchstart', (e) => {
                e.preventDefault();
                lookControls.active = true;
                updateLookControl(e.touches[0]);
            });
            
            lookControl.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (lookControls.active) {
                    updateLookControl(e.touches[0]);
                }
            });
            
            lookControl.addEventListener('touchend', () => {
                lookControls.active = false;
                lookControlKnob.style.transform = 'translate(-50%, -50%)';
                lookControls.x = 0;
                lookControls.y = 0;
            });
            
            // Setup camera sensitivity slider
            const cameraSensitivitySlider = document.getElementById('cameraSensitivitySlider');
            cameraSensitivitySlider.addEventListener('input', (e) => {
                cameraSensitivity = parseFloat(e.target.value);
            });
            
            // Setup pointer lock for mouse look
            document.addEventListener('pointerlockchange', onPointerLockChange);
            document.addEventListener('pointerlockerror', onPointerLockError);
            
            function updateJoystick(touch) {
                const rect = joystickContainer.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                const deltaX = touch.clientX - centerX;
                const deltaY = touch.clientY - centerY;
                
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                const maxDistance = rect.width / 2 - joystick.offsetWidth / 2;
                
                if (distance < maxDistance) {
                    joystick.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`;
                    joystickVector = {
                        x: deltaX / maxDistance,
                        y: deltaY / maxDistance
                    };
                } else {
                    const angle = Math.atan2(deltaY, deltaX);
                    const limitedX = Math.cos(angle) * maxDistance;
                    const limitedY = Math.sin(angle) * maxDistance;
                    
                    joystick.style.transform = `translate(calc(-50% + ${limitedX}px), calc(-50% + ${limitedY}px))`;
                    joystickVector = {
                        x: Math.cos(angle),
                        y: Math.sin(angle)
                    };
                }
            }
            
            function updateTouchJoystick(touch) {
                const rect = touchJoystick.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                const deltaX = touch.clientX - centerX;
                const deltaY = touch.clientY - centerY;
                
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                const maxDistance = rect.width / 2 - touchJoystickKnob.offsetWidth / 2;
                
                if (distance < maxDistance) {
                    touchJoystickKnob.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`;
                    joystickVector = {
                        x: deltaX / maxDistance,
                        y: deltaY / maxDistance
                    };
                } else {
                    const angle = Math.atan2(deltaY, deltaX);
                    const limitedX = Math.cos(angle) * maxDistance;
                    const limitedY = Math.sin(angle) * maxDistance;
                    
                    touchJoystickKnob.style.transform = `translate(calc(-50% + ${limitedX}px), calc(-50% + ${limitedY}px))`;
                    joystickVector = {
                        x: Math.cos(angle),
                        y: Math.sin(angle)
                    };
                }
            }
            
            function updateLookControl(touch) {
                const rect = lookControl.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                const deltaX = touch.clientX - centerX;
                const deltaY = touch.clientY - centerY;
                
                const maxDistance = rect.width / 2 - lookControlKnob.offsetWidth / 2;
                
                lookControlKnob.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`;
                lookControls.x = deltaX / maxDistance * 0.5 * cameraSensitivity;
                lookControls.y = deltaY / maxDistance * 0.5 * cameraSensitivity;
            }
        }
        
        function onPointerLockChange() {
            if (document.pointerLockElement === renderer.domElement) {
                isPointerLocked = true;
            } else {
                isPointerLocked = false;
            }
        }
        
        function onPointerLockError() {
            console.error('Pointer lock error');
        }
        
        function initMicrophone() {
            const microphoneButton = document.getElementById('microphoneButton');
            const microphoneVolumeSlider = document.getElementById('microphoneVolumeSlider');
            
            microphoneButton.addEventListener('click', toggleMicrophone);
            
            microphoneVolumeSlider.addEventListener('input', (e) => {
                microphoneVolume = parseFloat(e.target.value);
                document.getElementById('microphoneVolumeValue').textContent = `${Math.round(microphoneVolume * 100)}%`;
            });
        }
        
        function toggleMicrophone() {
            const microphoneButton = document.getElementById('microphoneButton');
            
            if (!microphoneEnabled) {
                // Request microphone access
                if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                    navigator.mediaDevices.getUserMedia({ audio: true })
                        .then(stream => {
                            microphoneStream = stream;
                            microphoneEnabled = true;
                            microphoneButton.classList.add('active');
                            
                            // Create audio context for processing
                            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                            const microphone = audioContext.createMediaStreamSource(stream);
                            const microphoneGain = audioContext.createGain();
                            
                            microphoneGain.gain.value = microphoneVolume;
                            microphone.connect(microphoneGain);
                            
                            // Store audio context for recording
                            window.microphoneAudioContext = audioContext;
                            window.microphoneGain = microphoneGain;
                        })
                        .catch(err => {
                            console.error('Error accessing microphone:', err);
                            alert('Error accessing microphone. Please ensure you have granted permission.');
                        });
                } else {
                    alert('Your browser does not support microphone access.');
                }
            } else {
                // Stop microphone
                if (microphoneStream) {
                    microphoneStream.getTracks().forEach(track => track.stop());
                    microphoneStream = null;
                }
                
                microphoneEnabled = false;
                microphoneButton.classList.remove('active');
            }
        }
        
        function toggleFirstPersonMode() {
            isFirstPersonMode = !isFirstPersonMode;
            const enterWorldButton = document.getElementById('enterWorldButton');
            const mobileControls = document.getElementById('mobileControls');
            const touchControls = document.getElementById('touchControls');
            const info = document.getElementById('info');
            const controls = document.getElementById('controls');
            const stats = document.getElementById('stats');
            const autoCameraControls = document.getElementById('autoCameraControls');
            
            if (isFirstPersonMode) {
                enterWorldButton.textContent = 'Exit World';
                enterWorldButton.classList.add('active');
                
                // Show mobile controls if on mobile
                if (isMobile) {
                    mobileControls.style.display = 'block';
                    touchControls.style.display = 'flex';
                }
                
                // Hide UI elements
                info.style.display = 'none';
                controls.style.display = 'none';
                stats.style.display = 'none';
                autoCameraControls.style.display = 'none';
                
                // Disable orbit controls
                controls.enabled = false;
                
                // Disable auto camera
                autoCameraEnabled = false;
                document.getElementById('autoCameraButton').classList.remove('active');
                
                // Request pointer lock
                renderer.domElement.requestPointerLock();
                
                // Create player body
                const playerShape = new CANNON.Box(new CANNON.Vec3(0.5, player.height / 2, 0.5));
                playerBody = new CANNON.Body({
                    mass: 70,
                    shape: playerShape,
                    position: new CANNON.Vec3(camera.position.x, camera.position.y - player.height / 2, camera.position.z)
                });
                
                // Add ground check to player
                playerBody.addEventListener('collide', (e) => {
                    if (e.body.position.y < -1.5) {
                        player.isOnGround = true;
                    }
                });
                
                if (isPhysicsEnabled) {
                    world.add(playerBody);
                }
                
                // Set camera to first person
                camera.position.set(playerBody.position.x, playerBody.position.y + player.height / 2, playerBody.position.z);
                
                // Add mouse movement for looking around
                document.addEventListener('mousemove', onMouseMoveFirstPerson);
            } else {
                enterWorldButton.textContent = 'Enter World';
                enterWorldButton.classList.remove('active');
                
                // Hide mobile controls
                mobileControls.style.display = 'none';
                touchControls.style.display = 'none';
                
                // Show UI elements
                info.style.display = 'block';
                controls.style.display = 'block';
                stats.style.display = 'block';
                autoCameraControls.style.display = 'block';
                
                // Enable orbit controls
                controls.enabled = true;
                
                // Remove pointer lock
                document.exitPointerLock();
                
                // Remove mouse movement listener
                document.removeEventListener('mousemove', onMouseMoveFirstPerson);
                
                // Remove player body
                if (playerBody && isPhysicsEnabled) {
                    world.remove(playerBody);
                    playerBody = null;
                }
                
                // Reset camera position
                camera.position.set(0, 10, 20);
            }
        }
        
        function onMouseMoveFirstPerson(event) {
            if (!isFirstPersonMode || !isPointerLocked) return;
            
            // Calculate mouse movement
            const movementX = event.movementX || 0;
            const movementY = event.movementY || 0;
            
            // Apply camera sensitivity
            const sensitivity = 0.002 * cameraSensitivity;
            
            // Update camera rotation
            camera.rotation.y -= movementX * sensitivity;
            camera.rotation.x -= movementY * sensitivity;
            
            // Limit vertical rotation to prevent flipping
            camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
        }
        
        function onKeyDown(event) {
            if (!isFirstPersonMode) return;
            
            switch (event.code) {
                case 'KeyW':
                    firstPersonControls.moveForward = true;
                    break;
                case 'KeyS':
                    firstPersonControls.moveBackward = true;
                    break;
                case 'KeyA':
                    firstPersonControls.moveLeft = true;
                    break;
                case 'KeyD':
                    firstPersonControls.moveRight = true;
                    break;
                case 'Space':
                    if (player.isOnGround) {
                        playerBody.velocity.y = player.jumpSpeed;
                        player.isOnGround = false;
                    }
                    break;
                case 'KeyE':
                    interactWithObject();
                    break;
            }
        }
        
        function onKeyUp(event) {
            if (!isFirstPersonMode) return;
            
            switch (event.code) {
                case 'KeyW':
                    firstPersonControls.moveForward = false;
                    break;
                case 'KeyS':
                    firstPersonControls.moveBackward = false;
                    break;
                case 'KeyA':
                    firstPersonControls.moveLeft = false;
                    break;
                case 'KeyD':
                    firstPersonControls.moveRight = false;
                    break;
            }
        }
        
        function updateFirstPersonControls() {
            if (!isFirstPersonMode || !playerBody) return;
            
            // Get camera direction
            camera.getWorldDirection(firstPersonControls.direction);
            
            // Calculate movement direction
            firstPersonControls.velocity.x -= firstPersonControls.velocity.x * 10.0 * 0.016; // Damping
            firstPersonControls.velocity.z -= firstPersonControls.velocity.z * 10.0 * 0.016; // Damping
            
            // Forward/backward movement
            if (firstPersonControls.moveForward) {
                firstPersonControls.velocity.z -= player.speed * firstPersonControls.direction.z;
                firstPersonControls.velocity.x -= player.speed * firstPersonControls.direction.x;
            }
            if (firstPersonControls.moveBackward) {
                firstPersonControls.velocity.z += player.speed * firstPersonControls.direction.z;
                firstPersonControls.velocity.x += player.speed * firstPersonControls.direction.x;
            }
            
            // Left/right movement
            const rightVector = new THREE.Vector3();
            rightVector.crossVectors(firstPersonControls.direction, camera.up).normalize();
            
            if (firstPersonControls.moveLeft) {
                firstPersonControls.velocity.x -= player.speed * rightVector.x;
                firstPersonControls.velocity.z -= player.speed * rightVector.z;
            }
            if (firstPersonControls.moveRight) {
                firstPersonControls.velocity.x += player.speed * rightVector.x;
                firstPersonControls.velocity.z += player.speed * rightVector.z;
            }
            
            // Apply joystick movement on mobile
            if (isMobile && joystickActive) {
                firstPersonControls.velocity.x += player.speed * joystickVector.x;
                firstPersonControls.velocity.z += player.speed * joystickVector.y;
            }
            
            // Apply look controls on mobile
            if (isMobile && lookControls.active) {
                camera.rotation.y -= lookControls.x;
                camera.rotation.x -= lookControls.y;
                
                // Limit vertical rotation
                camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
            }
            
            // Apply velocity to player body
            playerBody.velocity.x = firstPersonControls.velocity.x;
            playerBody.velocity.z = firstPersonControls.velocity.z;
            
            // Update camera position to follow player
            camera.position.x = playerBody.position.x;
            camera.position.y = playerBody.position.y + player.height / 2;
            camera.position.z = playerBody.position.z;
            
            // Check if player is on ground
            player.isOnGround = Math.abs(playerBody.velocity.y) < 0.1;
            
            // Update interaction prompt
            updateInteractionPrompt();
        }
        
        function updateInteractionPrompt() {
            const interactionPrompt = document.getElementById('interactionPrompt');
            let showPrompt = false;
            
            // Cast a ray forward from camera
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const intersects = raycaster.intersectObjects(objects, true);
            
            if (intersects.length > 0) {
                const distance = intersects[0].distance;
                
                if (distance < 3) { // Within interaction range
                    showPrompt = true;
                }
            }
            
            // Check for humans
            aiHumans.forEach(human => {
                if (!human.insideBuilding) {
                    const humanPosition = human.mesh.position.clone();
                    humanPosition.y += 1; // Check at chest level
                    
                    const distance = camera.position.distanceTo(humanPosition);
                    
                    if (distance < 3) { // Within interaction range
                        showPrompt = true;
                    }
                }
            });
            
            // Check for guns
            guns.forEach(gun => {
                if (!gun.isHeld) {
                    const distance = camera.position.distanceTo(gun.mesh.position);
                    
                    if (distance < 3) { // Within interaction range
                        showPrompt = true;
                    }
                }
            });
            
            // Show or hide prompt
            interactionPrompt.style.display = showPrompt ? 'block' : 'none';
        }
        
        function interactWithObject() {
            // Cast a ray forward from camera
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const intersects = raycaster.intersectObjects(objects, true);
            
            if (intersects.length > 0) {
                const distance = intersects[0].distance;
                
                if (distance < 3) { // Within interaction range
                    // Find the object
                    let object = intersects[0].object;
                    while (object.parent && !object.userData.interactable) {
                        object = object.parent;
                    }
                    
                    if (object.userData.interactable) {
                        // Handle interaction based on object type
                        if (object.userData.type === 'door') {
                            // Open/close door
                            const isOpen = object.userData.isOpen || false;
                            
                            if (isOpen) {
                                // Close door
                                object.rotation.y = 0;
                                object.userData.isOpen = false;
                            } else {
                                // Open door
                                object.rotation.y = Math.PI / 2;
                                object.userData.isOpen = true;
                            }
                        } else if (object.userData.type === 'tv') {
                            // Turn TV on/off
                            const isOn = object.userData.isOn || false;
                            
                            if (isOn) {
                                // Turn TV off
                                object.material.emissive = new THREE.Color(0x000000);
                                object.userData.isOn = false;
                            } else {
                                // Turn TV on
                                object.material.emissive = new THREE.Color(0x444444);
                                object.userData.isOn = true;
                            }
                        }
                    }
                }
            }
            
            // Check for humans
            aiHumans.forEach(human => {
                if (!human.insideBuilding) {
                    const humanPosition = human.mesh.position.clone();
                    humanPosition.y += 1; // Check at chest level
                    
                    const distance = camera.position.distanceTo(humanPosition);
                    
                    if (distance < 3) { // Within interaction range
                        // Interact with human
                        const emotionsList = Object.keys(speechPhrases);
                        const randomEmotion = emotionsList[Math.floor(Math.random() * emotionsList.length)];
                        const phrases = speechPhrases[randomEmotion];
                        const phrase = phrases[Math.floor(Math.random() * phrases.length)];
                        
                        showSpeech(human, phrase, 3000);
                        showEmotion(human, emotions.find(e => e.name === randomEmotion), 3000);
                        
                        // Make human face player
                        human.mesh.lookAt(camera.position);
                    }
                }
            });
            
            // Check for guns
            guns.forEach(gun => {
                if (!gun.isHeld) {
                    const distance = camera.position.distanceTo(gun.mesh.position);
                    
                    if (distance < 3) { // Within interaction range
                        // Pick up gun
                        gun.isHeld = true;
                        gun.holder = 'player';
                        
                        // Remove physics from gun
                        if (isPhysicsEnabled) {
                            world.remove(gun.body);
                        }
                    }
                }
            });
        }
        
        function initAutoCamera() {
            const autoCameraButton = document.getElementById('autoCameraButton');
            const cameraTargetList = document.getElementById('cameraTargetList');
            
            autoCameraButton.addEventListener('click', toggleAutoCamera);
            
            function toggleAutoCamera() {
                autoCameraEnabled = !autoCameraEnabled;
                autoCameraButton.textContent = autoCameraEnabled ? 'Disable Auto Camera' : 'Enable Auto Camera';
                autoCameraButton.classList.toggle('active');
                
                if (autoCameraEnabled) {
                    updateCameraTargets();
                    cameraTargetList.style.display = 'block';
                } else {
                    cameraTargetList.style.display = 'none';
                    cameraTarget = null;
                }
            }
            
            function updateCameraTargets() {
                // Clear existing targets
                cameraTargetList.innerHTML = '';
                cameraTargets = [];
                
                // Add humans as targets
                aiHumans.forEach((human, index) => {
                    const targetItem = document.createElement('div');
                    targetItem.className = 'camera-target-item';
                    targetItem.textContent = `Human ${index + 1}`;
                    targetItem.addEventListener('click', () => selectCameraTarget(human, targetItem));
                    cameraTargetList.appendChild(targetItem);
                    
                    cameraTargets.push({
                        object: human.mesh,
                        name: `Human ${index + 1}`,
                        type: 'human'
                    });
                });
                
                // Add objects as targets
                objects.forEach((object, index) => {
                    if (object.userData.draggable) {
                        const targetItem = document.createElement('div');
                        targetItem.className = 'camera-target-item';
                        targetItem.textContent = `Object ${index + 1}`;
                        targetItem.addEventListener('click', () => selectCameraTarget(object, targetItem));
                        cameraTargetList.appendChild(targetItem);
                        
                        cameraTargets.push({
                            object: object,
                            name: `Object ${index + 1}`,
                            type: 'object'
                        });
                    }
                });
                
                // Add trees as targets
                const trees = scene.children.filter(child => 
                    child.userData && child.userData.type === 'tree'
                );
                
                trees.forEach((tree, index) => {
                    const targetItem = document.createElement('div');
                    targetItem.className = 'camera-target-item';
                    targetItem.textContent = `Tree ${index + 1}`;
                    targetItem.addEventListener('click', () => selectCameraTarget(tree, targetItem));
                    cameraTargetList.appendChild(targetItem);
                    
                    cameraTargets.push({
                        object: tree,
                        name: `Tree ${index + 1}`,
                        type: 'tree'
                    });
                });
            }
            
            function selectCameraTarget(target, element) {
                // Remove active class from all items
                document.querySelectorAll('.camera-target-item').forEach(item => {
                    item.classList.remove('active');
                });
                
                // Add active class to selected item
                element.classList.add('active');
                
                // Set camera target
                cameraTarget = target;
            }
        }
        
        function updateAutoCamera() {
            if (!autoCameraEnabled || !cameraTarget || isFirstPersonMode) return;
            
            // Calculate target position
            const targetPosition = new THREE.Vector3();
            targetPosition.copy(cameraTarget.position);
            
            // Calculate desired camera position
            const desiredPosition = new THREE.Vector3();
            desiredPosition.copy(targetPosition);
            
            // Apply offset based on target type
            if (cameraTarget.type === 'human') {
                desiredPosition.y += 2; // Look at head level
                desiredPosition.add(cameraOffset);
            } else if (cameraTarget.type === 'object') {
                desiredPosition.y += 1; // Look at center
                desiredPosition.add(cameraOffset);
            } else if (cameraTarget.type === 'tree') {
                desiredPosition.y += 5; // Look at middle of tree
                desiredPosition.add(cameraOffset);
            }
            
            // Smoothly move camera to desired position
            camera.position.lerp(desiredPosition, 0.05);
            
            // Make camera look at target
            camera.lookAt(targetPosition);
            
            // Disable orbit controls when auto camera is active
            controls.enabled = false;
        }
        
        function initRecordingSystem() {
            // Create a hidden canvas for recording
            recordingCanvas = document.createElement('canvas');
            recordingCanvas.width = window.innerWidth;
            recordingCanvas.height = window.innerHeight;
            recordingContext = recordingCanvas.getContext('2d');
            
            // Setup recording controls
            document.getElementById('startRecording').addEventListener('click', startRecording);
            document.getElementById('stopRecording').addEventListener('click', stopRecording);
            document.getElementById('downloadVideo').addEventListener('click', downloadVideo);
            
            // Setup timelapse speed slider
            const timelapseSpeedSlider = document.getElementById('timelapseSpeedSlider');
            timelapseSpeedSlider.addEventListener('input', (e) => {
                timelapseSpeed = parseInt(e.target.value);
                document.getElementById('timelapseSpeedValue').textContent = `${timelapseSpeed}x`;
            });
            
            // Setup video quality slider
            const videoQualitySlider = document.getElementById('videoQualitySlider');
            videoQualitySlider.addEventListener('input', (e) => {
                videoQuality = parseFloat(e.target.value);
                document.getElementById('videoQualityValue').textContent = `${Math.round(videoQuality * 100)}%`;
            });
        }
        
        function startRecording() {
            if (isRecording) return;
            
            try {
                // Create a stream from the main renderer's canvas
                canvasStream = renderer.domElement.captureStream(30); // 30 FPS
                
                // Create audio track from microphone if enabled
                let audioStream = null;
                if (microphoneEnabled && microphoneStream) {
                    audioStream = new MediaStream([microphoneStream.getAudioTracks()[0]]);
                }
                
                // Combine video and audio streams
                const stream = new MediaStream([...canvasStream.getVideoTracks(), ...(audioStream ? audioStream.getAudioTracks() : [])]);
                
                // Setup media recorder with appropriate options
                const options = {
                    mimeType: 'video/webm;codecs=vp9',
                    videoBitsPerSecond: 5000000 * videoQuality, // Adjust quality based on slider
                    audioBitsPerSecond: audioStream ? 128000 * microphoneVolume : 0 // Adjust audio quality
                };
                
                // Check if the browser supports the specified mimeType
                if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                    options.mimeType = 'video/webm'; // Fallback to basic webm
                }
                
                mediaRecorder = new MediaRecorder(stream, options);
                
                recordedChunks = [];
                
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        recordedChunks.push(event.data);
                    }
                };
                
                mediaRecorder.onstop = () => {
                    const blob = new Blob(recordedChunks, {
                        type: options.mimeType
                    });
                    
                    // Enable download button
                    const downloadButton = document.getElementById('downloadVideo');
                    downloadButton.disabled = false;
                    downloadButton.blob = blob; // Store blob for download
                };
                
                // Start recording
                mediaRecorder.start();
                isRecording = true;
                recordingStartTime = Date.now();
                
                // Update UI
                document.getElementById('startRecording').disabled = true;
                document.getElementById('stopRecording').disabled = false;
                document.getElementById('recordingStatus').textContent = 'Recording';
                document.getElementById('recordingIndicator').style.display = 'block';
                
                // Start recording timer
                updateRecordingTime();
                recordingTimer = setInterval(updateRecordingTime, 1000);
                
                // Setup frame capture for timelapse effect
                setupFrameCapture();
                
            } catch (error) {
                console.error('Error starting recording:', error);
                alert('Error starting recording. Your browser may not support this feature.');
            }
        }
        
        function setupFrameCapture() {
            // Clear any existing interval
            if (frameCaptureInterval) {
                clearInterval(frameCaptureInterval);
            }
            
            // Calculate frame capture interval based on timelapse speed
            const captureInterval = Math.max(1, Math.floor(1000 / (30 / timelapseSpeed)));
            
            // Capture frames at the specified interval
            frameCaptureInterval = setInterval(() => {
                if (!isRecording) return;
                
                // Copy the main renderer's canvas to the recording canvas
                recordingContext.drawImage(renderer.domElement, 0, 0, recordingCanvas.width, recordingCanvas.height);
                
                // Draw additional UI elements if needed
                drawUIOnRecordingCanvas();
            }, captureInterval);
        }
        
        function drawUIOnRecordingCanvas() {
            // Save the current context state
            recordingContext.save();
            
            // Set text properties
            recordingContext.font = '16px Arial';
            recordingContext.fillStyle = 'white';
            recordingContext.textAlign = 'left';
            
            // Draw time display
            const hours = Math.floor(currentTime);
            const minutes = Math.floor((currentTime - hours) * 60);
            const timeString = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
            recordingContext.fillText(`Time: ${timeString}`, 20, 30);
            
            // Draw mode
            let mode = "Normal";
            if (isPhysicsEnabled) mode = "Physics";
            if (isRaining) mode = "Rain";
            if (isSnowing) mode = "Snow";
            if (isDayNightCycle) mode += " + Day/Night";
            if (isFirstPersonMode) mode += " + First Person";
            recordingContext.fillText(`Mode: ${mode}`, 20, 50);
            
            // Draw biome
            recordingContext.fillText(`Biome: ${currentBiome.charAt(0).toUpperCase() + currentBiome.slice(1)}`, 20, 70);
            
            // Draw stats
            recordingContext.textAlign = 'right';
            recordingContext.fillText(`Humans: ${aiHumans.length}`, recordingCanvas.width - 20, 30);
            recordingContext.fillText(`Guns: ${guns.length}`, recordingCanvas.width - 20, 50);
            recordingContext.fillText(`Armed: ${aiHumans.filter(h => h.heldGun !== null).length}`, recordingCanvas.width - 20, 70);
            recordingContext.fillText(`Water Level: ${Math.round(waterLevel)}%`, recordingCanvas.width - 20, 90);
            
            // Draw recording indicator
            recordingContext.fillStyle = 'rgba(244, 67, 54, 0.8)';
            recordingContext.fillRect(recordingCanvas.width / 2 - 60, 20, 120, 30);
            recordingContext.fillStyle = 'white';
            recordingContext.textAlign = 'center';
            recordingContext.fillText('● RECORDING', recordingCanvas.width / 2, 40);
            
            // Draw microphone indicator if enabled
            if (microphoneEnabled) {
                recordingContext.fillStyle = 'rgba(33, 150, 243, 0.8)';
                recordingContext.fillRect(recordingCanvas.width / 2 - 60, 55, 120, 30);
                recordingContext.fillStyle = 'white';
                recordingContext.fillText('🎤 MICROPHONE ON', recordingCanvas.width / 2, 75);
            }
            
            // Restore the context state
            recordingContext.restore();
        }
        
        function updateRecordingTime() {
            if (!isRecording) return;
            
            const elapsed = Date.now() - recordingStartTime;
            const minutes = Math.floor(elapsed / 60000);
            const seconds = Math.floor((elapsed % 60000) / 1000);
            
            document.getElementById('recordingTime').textContent = 
                `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }
        
        function stopRecording() {
            if (!isRecording) return;
            
            // Stop media recorder
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
            }
            
            // Stop frame capture
            if (frameCaptureInterval) {
                clearInterval(frameCaptureInterval);
                frameCaptureInterval = null;
            }
            
            // Stop recording timer
            if (recordingTimer) {
                clearInterval(recordingTimer);
                recordingTimer = null;
            }
            
            // Update UI
            isRecording = false;
            document.getElementById('startRecording').disabled = false;
            document.getElementById('stopRecording').disabled = true;
            document.getElementById('recordingStatus').textContent = 'Not Recording';
            document.getElementById('recordingIndicator').style.display = 'none';
        }
        
        function downloadVideo() {
            const downloadButton = document.getElementById('downloadVideo');
            if (!downloadButton.blob) return;
            
            // Create a download link
            const url = URL.createObjectURL(downloadButton.blob);
            const a = document.createElement('a');
            a.style.display = 'none';
            a.href = url;
            
            // Generate filename with timestamp
            const now = new Date();
            const timestamp = now.toISOString().replace(/[:.]/g, '-').slice(0, -5);
            a.download = `3d-world-timelapse-${timestamp}.webm`;
            
            // Trigger download
            document.body.appendChild(a);
            a.click();
            
            // Clean up
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 100);
        }
        
        function initWaterGrid() {
            // Initialize water grid to track water levels
            const gridSize = 150 / waterGridSize; // Increased land size
            for (let x = -gridSize/2; x < gridSize/2; x++) {
                for (let z = -gridSize/2; z < gridSize/2; z++) {
                    const key = `${x},${z}`;
                    waterGrid[key] = 0; // Initialize with no water
                }
            }
        }
        
        function createObjects() {
            // Create cube
            const cubeGeometry = new THREE.BoxGeometry(1, 1, 1);
            const cubeMaterial = new THREE.MeshPhongMaterial({ color: 0x3498db });
            cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
            cube.position.set(-2, 2, 0);
            cube.castShadow = true;
            cube.receiveShadow = true;
            cube.userData = { draggable: true };
            scene.add(cube);
            objects.push(cube);
            
            // Create sphere
            const sphereGeometry = new THREE.SphereGeometry(0.7, 32, 32);
            const sphereMaterial = new THREE.MeshPhongMaterial({ color: 0xe74c3c });
            sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            sphere.position.set(0, 3, 0);
            sphere.castShadow = true;
            sphere.receiveShadow = true;
            sphere.userData = { draggable: true };
            scene.add(sphere);
            objects.push(sphere);
            
            // Create torus
            const torusGeometry = new THREE.TorusGeometry(0.7, 0.3, 16, 100);
            const torusMaterial = new THREE.MeshPhongMaterial({ color: 0x2ecc71 });
            torus = new THREE.Mesh(torusGeometry, torusMaterial);
            torus.position.set(2, 4, 0);
            torus.castShadow = true;
            torus.receiveShadow = true;
            torus.userData = { draggable: true };
            scene.add(torus);
            objects.push(torus);
        }
        
        function createBiome(biomeType) {
            // Remove existing ground
            if (ground) {
                scene.remove(ground);
            }
            
            // Remove existing grass
            grassBlades.forEach(blade => {
                scene.remove(blade);
            });
            grassBlades = [];
            
            // Remove existing snow
            snowOnGround.forEach(snow => {
                scene.remove(snow);
            });
            snowOnGround = [];
            
            // Remove existing water
            waterMeshes.forEach(water => {
                scene.remove(water);
            });
            waterMeshes = [];
            
            // Remove existing maze walls
            mazeWalls.forEach(wall => {
                scene.remove(wall.mesh);
                if (isPhysicsEnabled && wall.body) {
                    world.remove(wall.body);
                }
            });
            mazeWalls = [];
            
            // Remove existing luxury houses
            if (window.luxuryHouses) {
                window.luxuryHouses.forEach(house => {
                    scene.remove(house.mesh);
                    if (isPhysicsEnabled && house.body) {
                        world.remove(house.body);
                    }
                });
                window.luxuryHouses = [];
            }
            
            // Reset water grid
            initWaterGrid();
            waterLevel = 0;
            updateWaterLevelDisplay();
            
            // Create visual ground based on biome
            const groundGeometry = new THREE.PlaneGeometry(150, 150); // Increased land size
            let groundMaterial;
            
            switch(biomeType) {
                case 'forest':
                    groundMaterial = new THREE.MeshPhongMaterial({ 
                        color: 0x4d7c0f, // Forest green
                        side: THREE.DoubleSide 
                    });
                    break;
                case 'desert':
                    groundMaterial = new THREE.MeshPhongMaterial({ 
                        color: 0xe2ca76, // Sandy color
                        side: THREE.DoubleSide 
                    });
                    break;
                case 'snow':
                    groundMaterial = new THREE.MeshPhongMaterial({ 
                        color: 0xffffff, // Snow white
                        side: THREE.DoubleSide 
                    });
                    break;
                case 'jungle':
                    groundMaterial = new THREE.MeshPhongMaterial({ 
                        color: 0x3a5f0b, // Dark green
                        side: THREE.DoubleSide 
                    });
                    break;
                case 'volcano':
                    groundMaterial = new THREE.MeshPhongMaterial({ 
                        color: 0x4a1a1a, // Dark red/brown
                        side: THREE.DoubleSide 
                    });
                    break;
                case 'island':
                    groundMaterial = new THREE.MeshPhongMaterial({ 
                        color: 0xc2b280, // Beach sand
                        side: THREE.DoubleSide 
                    });
                    break;
                case 'town':
                    groundMaterial = new THREE.MeshPhongMaterial({ 
                        color: 0x808080, // Gray for roads
                        side: THREE.DoubleSide 
                    });
                    break;
                case 'maze':
                    groundMaterial = new THREE.MeshPhongMaterial({ 
                        color: 0x8B4513, // Brown for maze floor
                        side: THREE.DoubleSide 
                    });
                    break;
                case 'luxury':
                    groundMaterial = new THREE.MeshPhongMaterial({ 
                        color: 0x2E8B57, // Grass green
                        side: THREE.DoubleSide 
                    });
                    break;
                default:
                    groundMaterial = new THREE.MeshPhongMaterial({ 
                        color: 0x4d7c0f, // Default forest green
                        side: THREE.DoubleSide 
                    });
            }
            
            ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = Math.PI / 2;
            ground.position.y = -2;
            ground.receiveShadow = true;
            ground.userData = { biome: biomeType };
            scene.add(ground);
            
            // Create physics ground
            const groundShape = new CANNON.Plane();
            const groundBody = new CANNON.Body({
                mass: 0, // Static body
                shape: groundShape
            });
            groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
            world.add(groundBody);
            
            // Add biome-specific features
            addBiomeFeatures(biomeType);
            
            // Add grass for forest and jungle biomes
            if (biomeType === 'forest' || biomeType === 'jungle') {
                addGrass(1000); // Add 1000 grass blades
            }
            
            // Update current biome
            currentBiome = biomeType;
            document.getElementById('currentBiome').textContent = biomeType.charAt(0).toUpperCase() + biomeType.slice(1);
            
            // Update camera targets if auto camera is enabled
            if (autoCameraEnabled) {
                updateCameraTargets();
            }
        }
        
        function addGrass(count) {
            // Create realistic 3D grass
            for (let i = 0; i < count; i++) {
                // Random position within the ground area
                const x = (Math.random() - 0.5) * 150; // Increased land size
                const z = (Math.random() - 0.5) * 150; // Increased land size
                
                // Create a single grass blade
                const grassHeight = 0.2 + Math.random() * 0.3; // Random height between 0.2 and 0.5
                const grassWidth = 0.05 + Math.random() * 0.05; // Random width
                
                const grassGeometry = new THREE.ConeGeometry(grassWidth, grassHeight, 4); // 4-sided cone for grass blade
                const grassMaterial = new THREE.MeshPhongMaterial({ 
                    color: currentBiome === 'forest' ? 0x3a7e3a : 0x2d5a2d, // Different greens for forest vs jungle
                    side: THREE.DoubleSide 
                });
                
                const grassBlade = new THREE.Mesh(grassGeometry, grassMaterial);
                
                // Position the grass blade
                grassBlade.position.set(x, -2 + grassHeight/2, z); // Position on ground with half height above
                
                // Add some random rotation for natural look
                grassBlade.rotation.x = (Math.random() - 0.5) * 0.2;
                grassBlade.rotation.z = (Math.random() - 0.5) * 0.2;
                
                // Make grass cast and receive shadows
                grassBlade.castShadow = true;
                grassBlade.receiveShadow = true;
                
                // Add to scene and track
                scene.add(grassBlade);
                grassBlades.push(grassBlade);
                objects.push(grassBlade);
                
                // Add physics body for grass (optional, can be disabled for performance)
                const grassShape = new CANNON.Box(new CANNON.Vec3(grassWidth/2, grassHeight/2, grassWidth/2));
                const grassBody = new CANNON.Body({
                    mass: 0, // Static body
                    shape: grassShape,
                    position: new CANNON.Vec3(x, -2 + grassHeight/2, z)
                });
                
                if (isPhysicsEnabled) {
                    world.add(grassBody);
                }
                
                // Store reference to physics body
                grassBlade.userData.body = grassBody;
            }
        }
        
        function addBiomeFeatures(biomeType) {
            // Add biome-specific objects
            switch(biomeType) {
                case 'forest':
                    addTrees(30);
                    break;
                case 'desert':
                    addCacti(15);
                    addRocks(20);
                    break;
                case 'snow':
                    addSnowmen(5);
                    addPineTrees(20);
                    break;
                case 'jungle':
                    addJungleTrees(25);
                    addVines(15);
                    break;
                case 'volcano':
                    addVolcano();
                    addLavaRocks(30);
                    break;
                case 'island':
                    addPalmTrees(15);
                    addBeachObjects(20);
                    break;
                case 'town':
                    addTownFeatures();
                    break;
                case 'maze':
                    generateMaze();
                    break;
                case 'luxury':
                    addLuxuryHouses(5);
                    break;
            }
        }
        
        function addLuxuryHouses(count) {
            window.luxuryHouses = [];
            
            for (let i = 0; i < count; i++) {
                const houseGroup = new THREE.Group();
                
                // Determine position
                const x = (Math.random() - 0.5) * 120; // Increased land size
                const z = (Math.random() - 0.5) * 120; // Increased land size
                
                // Create luxury house with multiple floors
                createLuxuryHouse(houseGroup, x, z);
                
                scene.add(houseGroup);
                objects.push(houseGroup);
                
                // Store house data for human interactions
                const houseData = {
                    mesh: houseGroup,
                    position: new THREE.Vector3(x, 0, z),
                    size: new THREE.Vector3(12, 8, 12),
                    occupants: [],
                    doors: [],
                    rooms: []
                };
                
                window.luxuryHouses.push(houseData);
                
                // Add physics body for house
                const houseShape = new CANNON.Box(new CANNON.Vec3(6, 4, 6));
                const houseBody = new CANNON.Body({
                    mass: 0, // Static body
                    shape: houseShape,
                    position: new CANNON.Vec3(x, 2, z)
                });
                
                if (isPhysicsEnabled) {
                    world.add(houseBody);
                }
                
                houseData.body = houseBody;
            }
        }
        
        function createLuxuryHouse(houseGroup, x, z) {
            // Ground floor
            const groundFloorGeometry = new THREE.BoxGeometry(12, 4, 12);
            const groundFloorMaterial = new THREE.MeshPhongMaterial({ color: 0xF5F5DC });
            const groundFloor = new THREE.Mesh(groundFloorGeometry, groundFloorMaterial);
            groundFloor.position.set(0, 0, 0);
            groundFloor.castShadow = true;
            groundFloor.receiveShadow = true;
            houseGroup.add(groundFloor);
            
            // First floor
            const firstFloorGeometry = new THREE.BoxGeometry(12, 3, 12);
            const firstFloorMaterial = new THREE.MeshPhongMaterial({ color: 0xF5F5DC });
            const firstFloor = new THREE.Mesh(firstFloorGeometry, firstFloorMaterial);
            firstFloor.position.set(0, 4, 0);
            firstFloor.castShadow = true;
            firstFloor.receiveShadow = true;
            houseGroup.add(firstFloor);
            
            // Roof
            const roofGeometry = new THREE.ConeGeometry(9, 3, 4);
            const roofMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
            const roof = new THREE.Mesh(roofGeometry, roofMaterial);
            roof.position.set(0, 7.5, 0);
            roof.rotation.y = Math.PI / 4;
            roof.castShadow = true;
            houseGroup.add(roof);
            
            // Front door
            const doorGeometry = new THREE.BoxGeometry(2, 3.5, 0.2);
            const doorMaterial = new THREE.MeshPhongMaterial({ color: 0x654321 });
            const frontDoor = new THREE.Mesh(doorGeometry, doorMaterial);
            frontDoor.position.set(0, -0.25, 6.1);
            frontDoor.userData = { 
                type: 'door', 
                isOpen: false,
                interactable: true
            };
            houseGroup.add(frontDoor);
            
            // Back door
            const backDoor = new THREE.Mesh(doorGeometry, doorMaterial);
            backDoor.position.set(0, -0.25, -6.1);
            backDoor.rotation.y = Math.PI;
            backDoor.userData = { 
                type: 'door', 
                isOpen: false,
                interactable: true
            };
            houseGroup.add(backDoor);
            
            // Windows
            const windowGeometry = new THREE.BoxGeometry(1.5, 1.5, 0.2);
            const windowMaterial = new THREE.MeshPhongMaterial({ color: 0x87CEEB });
            
            // Front windows
            const frontWindow1 = new THREE.Mesh(windowGeometry, windowMaterial);
            frontWindow1.position.set(-3, 1, 6.1);
            houseGroup.add(frontWindow1);
            
            const frontWindow2 = new THREE.Mesh(windowGeometry, windowMaterial);
            frontWindow2.position.set(3, 1, 6.1);
            houseGroup.add(frontWindow2);
            
            // Back windows
            const backWindow1 = new THREE.Mesh(windowGeometry, windowMaterial);
            backWindow1.position.set(-3, 1, -6.1);
            backWindow1.rotation.y = Math.PI;
            houseGroup.add(backWindow1);
            
            const backWindow2 = new THREE.Mesh(windowGeometry, windowMaterial);
            backWindow2.position.set(3, 1, -6.1);
            backWindow2.rotation.y = Math.PI;
            houseGroup.add(backWindow2);
            
            // Side windows
            const sideWindow1 = new THREE.Mesh(windowGeometry, windowMaterial);
            sideWindow1.position.set(6.1, 1, -3);
            sideWindow1.rotation.y = Math.PI / 2;
            houseGroup.add(sideWindow1);
            
            const sideWindow2 = new THREE.Mesh(windowGeometry, windowMaterial);
            sideWindow2.position.set(6.1, 1, 3);
            sideWindow2.rotation.y = Math.PI / 2;
            houseGroup.add(sideWindow2);
            
            const sideWindow3 = new THREE.Mesh(windowGeometry, windowMaterial);
            sideWindow3.position.set(-6.1, 1, -3);
            sideWindow3.rotation.y = -Math.PI / 2;
            houseGroup.add(sideWindow3);
            
            const sideWindow4 = new THREE.Mesh(windowGeometry, windowMaterial);
            sideWindow4.position.set(-6.1, 1, 3);
            sideWindow4.rotation.y = -Math.PI / 2;
            houseGroup.add(sideWindow4);
            
            // Second floor windows
            const secondFloorWindow1 = new THREE.Mesh(windowGeometry, windowMaterial);
            secondFloorWindow1.position.set(-3, 5, 6.1);
            houseGroup.add(secondFloorWindow1);
            
            const secondFloorWindow2 = new THREE.Mesh(windowGeometry, windowMaterial);
            secondFloorWindow2.position.set(3, 5, 6.1);
            houseGroup.add(secondFloorWindow2);
            
            // Side windows
            const secondSideWindow1 = new THREE.Mesh(windowGeometry, windowMaterial);
            secondSideWindow1.position.set(6.1, 5, -3);
            secondSideWindow1.rotation.y = Math.PI / 2;
            houseGroup.add(secondSideWindow1);
            
            const secondSideWindow2 = new THREE.Mesh(windowGeometry, windowMaterial);
            secondSideWindow2.position.set(6.1, 5, 3);
            secondSideWindow2.rotation.y = Math.PI / 2;
            houseGroup.add(secondSideWindow2);
            
            const secondSideWindow3 = new THREE.Mesh(windowGeometry, windowMaterial);
            secondSideWindow3.position.set(-6.1, 5, -3);
            secondSideWindow3.rotation.y = -Math.PI / 2;
            houseGroup.add(secondSideWindow3);
            
            const secondSideWindow4 = new THREE.Mesh(windowGeometry, windowMaterial);
            secondSideWindow4.position.set(-6.1, 5, 3);
            secondSideWindow4.rotation.y = -Math.PI / 2;
            houseGroup.add(secondSideWindow4);
            
            // Garage
            const garageGeometry = new THREE.BoxGeometry(6, 3, 8);
            const garageMaterial = new THREE.MeshPhongMaterial({ color: 0xD3D3D3 });
            const garage = new THREE.Mesh(garageGeometry, garageMaterial);
            garage.position.set(0, -0.5, -10);
            garage.castShadow = true;
            garage.receiveShadow = true;
            houseGroup.add(garage);
            
            // Garage door
            const garageDoorGeometry = new THREE.BoxGeometry(5, 2.5, 0.2);
            const garageDoorMaterial = new THREE.MeshPhongMaterial({ color: 0x808080 });
            const garageDoor = new THREE.Mesh(garageDoorGeometry, garageDoorMaterial);
            garageDoor.position.set(0, -0.75, -14.1);
            garageDoor.userData = { 
                type: 'door', 
                isOpen: false,
                interactable: true
            };
            houseGroup.add(garageDoor);
            
            // Chimney
            const chimneyGeometry = new THREE.BoxGeometry(1.5, 3, 1.5);
            const chimneyMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
            const chimney = new THREE.Mesh(chimneyGeometry, chimneyMaterial);
            chimney.position.set(4, 6, 4);
            chimney.castShadow = true;
            houseGroup.add(chimney);
            
            // Balcony
            const balconyGeometry = new THREE.BoxGeometry(8, 0.2, 3);
            const balconyMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
            const balcony = new THREE.Mesh(balconyGeometry, balconyMaterial);
            balcony.position.set(0, 4, -7.5);
            balcony.castShadow = true;
            houseGroup.add(balcony);
            
            // Balcony railing
            const railingGeometry = new THREE.BoxGeometry(0.2, 1.5, 0.2);
            const railingMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
            
            for (let i = -3.5; i <= 3.5; i += 0.5) {
                const railing = new THREE.Mesh(railingGeometry, railingMaterial);
                railing.position.set(i, 4.75, -8.5);
                houseGroup.add(railing);
            }
            
            // Swimming pool
            const poolGeometry = new THREE.BoxGeometry(8, 0.5, 6);
            const poolMaterial = new THREE.MeshPhongMaterial({ color: 0x1E90FF });
            const pool = new THREE.Mesh(poolGeometry, poolMaterial);
            pool.position.set(15, -1.75, 0);
            pool.receiveShadow = true;
            houseGroup.add(pool);
            
            // Pool edges
            const poolEdgeGeometry = new THREE.BoxGeometry(8.5, 0.3, 6.5);
            const poolEdgeMaterial = new THREE.MeshPhongMaterial({ color: 0xCCCCCC });
            const poolEdge = new THREE.Mesh(poolEdgeGeometry, poolEdgeMaterial);
            poolEdge.position.set(15, -1.9, 0);
            poolEdge.castShadow = true;
            poolEdge.receiveShadow = true;
            houseGroup.add(poolEdge);
            
            // Furniture inside (visible when doors are open)
            // Living room sofa
            const sofaGeometry = new THREE.BoxGeometry(3, 1, 1.5);
            const sofaMaterial = new THREE.MeshPhongMaterial({ color: 0x4682B4 });
            const sofa = new THREE.Mesh(sofaGeometry, sofaMaterial);
            sofa.position.set(0, -1.5, 2);
            houseGroup.add(sofa);
            
            // Living room TV
            const tvGeometry = new THREE.BoxGeometry(2, 1.2, 0.2);
            const tvMaterial = new THREE.MeshPhongMaterial({ color: 0x000000 });
            const tv = new THREE.Mesh(tvGeometry, tvMaterial);
            tv.position.set(0, 0, 5.9);
            tv.userData = { 
                type: 'tv', 
                isOn: false,
                interactable: true
            };
            houseGroup.add(tv);
            
            // Kitchen counter
            const counterGeometry = new THREE.BoxGeometry(4, 2, 1);
            const counterMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
            const counter = new THREE.Mesh(counterGeometry, counterMaterial);
            counter.position.set(-4, -1, -2);
            houseGroup.add(counter);
            
            // Kitchen stove
            const stoveGeometry = new THREE.BoxGeometry(1, 0.1, 1);
            const stoveMaterial = new THREE.MeshPhongMaterial({ color: 0x2F4F4F });
            const stove = new THREE.Mesh(stoveGeometry, stoveMaterial);
            stove.position.set(-4, -0.05, -2);
            houseGroup.add(stove);
            
            // Kitchen sink
            const sinkGeometry = new THREE.BoxGeometry(1, 0.2, 0.8);
            const sinkMaterial = new THREE.MeshPhongMaterial({ color: 0xC0C0C0 });
            const sink = new THREE.Mesh(sinkGeometry, sinkMaterial);
            sink.position.set(-2, -0.9, -2);
            houseGroup.add(sink);
            
            // Bedroom bed
            const bedGeometry = new THREE.BoxGeometry(2, 0.5, 3);
            const bedMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
            const bed = new THREE.Mesh(bedGeometry, bedMaterial);
            bed.position.set(0, -1.75, -2);
            houseGroup.add(bed);
            
            // Bedroom dresser
            const dresserGeometry = new THREE.BoxGeometry(2, 1.5, 0.8);
            const dresserMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
            const dresser = new THREE.Mesh(dresserGeometry, dresserMaterial);
            dresser.position.set(0, -1.25, -4);
            houseGroup.add(dresser);
            
            // Bathroom toilet
            const toiletGeometry = new THREE.CylinderGeometry(0.4, 0.4, 0.6, 16);
            const toiletMaterial = new THREE.MeshPhongMaterial({ color: 0xFFFFFF });
            const toilet = new THREE.Mesh(toiletGeometry, toiletMaterial);
            toilet.position.set(4, -1.7, -4);
            houseGroup.add(toilet);
            
            // Bathroom sink
            const bathroomSinkGeometry = new THREE.BoxGeometry(0.8, 0.1, 0.6);
            const bathroomSinkMaterial = new THREE.MeshPhongMaterial({ color: 0xFFFFFF });
            const bathroomSink = new THREE.Mesh(bathroomSinkGeometry, bathroomSinkMaterial);
            bathroomSink.position.set(4, -1.4, -2.5);
            houseGroup.add(bathroomSink);
            
            // Bathroom shower
            const showerGeometry = new THREE.BoxGeometry(1, 2, 1);
            const showerMaterial = new THREE.MeshPhongMaterial({ color: 0xE0FFFF, transparent: true, opacity: 0.5 });
            const shower = new THREE.Mesh(showerGeometry, showerMaterial);
            shower.position.set(4, -0.5, -4);
            houseGroup.add(shower);
            
            // Stairs to second floor
            const stairGeometry = new THREE.BoxGeometry(2, 0.2, 0.8);
            const stairMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
            
            for (let i = 0; i < 10; i++) {
                const stair = new THREE.Mesh(stairGeometry, stairMaterial);
                stair.position.set(0, -1.8 + i * 0.4, -0.8 + i * 0.16);
                stair.rotation.x = Math.PI / 8;
                houseGroup.add(stair);
            }
            
            // Second floor bedroom
            const secondBedGeometry = new THREE.BoxGeometry(2, 0.5, 3);
            const secondBedMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
            const secondBed = new THREE.Mesh(secondBedGeometry, secondBedMaterial);
            secondBed.position.set(0, 2.25, 2);
            houseGroup.add(secondBed);
            
            // Second floor dresser
            const secondDresserGeometry = new THREE.BoxGeometry(2, 1.5, 0.8);
            const secondDresserMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
            const secondDresser = new THREE.Mesh(secondDresserGeometry, secondDresserMaterial);
            secondDresser.position.set(0, 2.75, 4);
            houseGroup.add(secondDresser);
            
            // Second floor bathroom
            const secondToiletGeometry = new THREE.CylinderGeometry(0.4, 0.4, 0.6, 16);
            const secondToiletMaterial = new THREE.MeshPhongMaterial({ color: 0xFFFFFF });
            const secondToilet = new THREE.Mesh(secondToiletGeometry, secondToiletMaterial);
            secondToilet.position.set(-4, 2.3, 4);
            houseGroup.add(secondToilet);
            
            // Second floor sink
            const secondBathroomSinkGeometry = new THREE.BoxGeometry(0.8, 0.1, 0.6);
            const secondBathroomSinkMaterial = new THREE.MeshPhongMaterial({ color: 0xFFFFFF });
            const secondBathroomSink = new THREE.Mesh(secondBathroomSinkGeometry, secondBathroomSinkMaterial);
            secondBathroomSink.position.set(-4, 2.6, 2.5);
            houseGroup.add(secondBathroomSink);
            
            // Second floor shower
            const secondShowerGeometry = new THREE.BoxGeometry(1, 2, 1);
            const secondShowerMaterial = new THREE.MeshPhongMaterial({ color: 0xE0FFFF, transparent: true, opacity: 0.5 });
            const secondShower = new THREE.Mesh(secondShowerGeometry, secondShowerMaterial);
            secondShower.position.set(-4, 3.5, 4);
            houseGroup.add(secondShower);
            
            // Second floor TV
            const secondTvGeometry = new THREE.BoxGeometry(2, 1.2, 0.2);
            const secondTvMaterial = new THREE.MeshPhongMaterial({ color: 0x000000 });
            const secondTv = new THREE.Mesh(secondTvGeometry, secondTvMaterial);
            secondTv.position.set(0, 3.8, -5.9);
            secondTv.userData = { 
                type: 'tv', 
                isOn: false,
                interactable: true
            };
            houseGroup.add(secondTv);
            
            // Second floor sofa
            const secondSofaGeometry = new THREE.BoxGeometry(3, 1, 1.5);
            const secondSofaMaterial = new THREE.MeshPhongMaterial({ color: 0x4682B4 });
            const secondSofa = new THREE.Mesh(secondSofaGeometry, secondSofaMaterial);
            secondSofa.position.set(0, 2.5, -2);
            houseGroup.add(secondSofa);
            
            // Position house
            houseGroup.position.set(x, 0, z);
            
            // Store door positions for entering/exiting
            const frontDoorPos = new THREE.Vector3(x, 0.75, z + 6.1);
            const backDoorPos = new THREE.Vector3(x, 0.75, z - 6.1);
            const garageDoorPos = new THREE.Vector3(x, 0.75, z - 14.1);
            
            if (window.luxuryHouses && window.luxuryHouses.length > 0) {
                const houseIndex = window.luxuryHouses.length - 1;
                window.luxuryHouses[houseIndex].doors = [frontDoorPos, backDoorPos, garageDoorPos];
            }
        }
        
        function generateMaze() {
            // Create a maze using recursive backtracking algorithm
            const maze = [];
            for (let i = 0; i < mazeSize; i++) {
                maze[i] = [];
                for (let j = 0; j < mazeSize; j++) {
                    maze[i][j] = 1; // 1 = wall, 0 = path
                }
            }
            
            // Recursive backtracking function
            function carvePath(x, y) {
                maze[x][y] = 0; // Mark as path
                
                // Define directions: up, right, down, left
                const directions = [
                    [0, -2], [2, 0], [0, 2], [-2, 0]
                ];
                
                // Shuffle directions
                for (let i = directions.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [directions[i], directions[j]] = [directions[j], directions[i]];
                }
                
                // Try each direction
                for (const [dx, dy] of directions) {
                    const nx = x + dx;
                    const ny = y + dy;
                    
                    // Check if the new position is within bounds and is a wall
                    if (nx >= 0 && nx < mazeSize && ny >= 0 && ny < mazeSize && maze[nx][ny] === 1) {
                        // Carve path to the new position
                        maze[x + dx/2][y + dy/2] = 0; // Remove wall between current and new position
                        carvePath(nx, ny);
                    }
                }
            }
            
            // Start carving from the top-left corner
            carvePath(1, 1);
            
            // Ensure entrance and exit
            maze[1][0] = 0; // Entrance
            maze[mazeSize-2][mazeSize-1] = 0; // Exit
            
            // Create maze walls in 3D
            const wallHeight = 3;
            const wallThickness = 0.5;
            
            for (let i = 0; i < mazeSize; i++) {
                for (let j = 0; j < mazeSize; j++) {
                    if (maze[i][j] === 1) {
                        // Create wall
                        const wallGeometry = new THREE.BoxGeometry(cellSize, wallHeight, cellSize);
                        const wallMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
                        const wall = new THREE.Mesh(wallGeometry, wallMaterial);
                        
                        // Position wall
                        wall.position.set(
                            (i - mazeSize/2) * cellSize,
                            -2 + wallHeight/2,
                            (j - mazeSize/2) * cellSize
                        );
                        
                        wall.castShadow = true;
                        wall.receiveShadow = true;
                        scene.add(wall);
                        objects.push(wall);
                        
                        // Create physics body for wall
                        const wallShape = new CANNON.Box(new CANNON.Vec3(cellSize/2, wallHeight/2, cellSize/2));
                        const wallBody = new CANNON.Body({
                            mass: 0, // Static body
                            shape: wallShape,
                            position: new CANNON.Vec3(
                                (i - mazeSize/2) * cellSize,
                                -2 + wallHeight/2,
                                (j - mazeSize/2) * cellSize
                            )
                        });
                        
                        if (isPhysicsEnabled) {
                            world.add(wallBody);
                        }
                        
                        mazeWalls.push({
                            mesh: wall,
                            body: wallBody,
                            position: wall.position.clone(),
                            size: new THREE.Vector3(cellSize, wallHeight, cellSize)
                        });
                    }
                }
            }
            
            // Add some decorative elements to the maze
            for (let i = 0; i < 5; i++) {
                const torchGeometry = new THREE.CylinderGeometry(0.1, 0.1, 1, 8);
                const torchMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
                const torch = new THREE.Mesh(torchGeometry, torchMaterial);
                
                // Find a random path position for the torch
                let x, z;
                do {
                    x = Math.floor(Math.random() * mazeSize);
                    z = Math.floor(Math.random() * mazeSize);
                } while (maze[x][z] === 1);
                
                torch.position.set(
                    (x - mazeSize/2) * cellSize,
                    -1.5,
                    (z - mazeSize/2) * cellSize
                );
                
                scene.add(torch);
                objects.push(torch);
                
                // Add flame to torch
                const flameGeometry = new THREE.SphereGeometry(0.2, 8, 8);
                const flameMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xFF4500,
                    transparent: true,
                    opacity: 0.8
                });
                const flame = new THREE.Mesh(flameGeometry, flameMaterial);
                flame.position.copy(torch.position);
                flame.position.y += 0.6;
                scene.add(flame);
                objects.push(flame);
                
                // Add point light for flame
                const flameLight = new THREE.PointLight(0xFF4500, 1, 10);
                flameLight.position.copy(flame.position);
                scene.add(flameLight);
            }
        }
        
        function addTrees(count) {
            const treeGeometry = new THREE.CylinderGeometry(0.2, 0.3, 3, 8);
            const leavesGeometry = new THREE.SphereGeometry(1.5, 8, 6);
            
            for (let i = 0; i < count; i++) {
                // Tree trunk
                const trunkMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
                const trunk = new THREE.Mesh(treeGeometry, trunkMaterial);
                trunk.position.set(
                    (Math.random() - 0.5) * 120, // Increased land size
                    -0.5,
                    (Math.random() - 0.5) * 120  // Increased land size
                );
                trunk.castShadow = true;
                trunk.receiveShadow = true;
                scene.add(trunk);
                
                // Tree leaves
                const leavesMaterial = new THREE.MeshPhongMaterial({ color: 0x2E8B57 });
                const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
                leaves.position.copy(trunk.position);
                leaves.position.y += 2;
                leaves.castShadow = true;
                leaves.receiveShadow = true;
                scene.add(leaves);
                
                objects.push(trunk, leaves);
                
                // Add physics body for tree trunk
                const trunkShape = new CANNON.Cylinder(0.2, 0.3, 3, 8);
                const trunkBody = new CANNON.Body({
                    mass: 0, // Static body
                    shape: trunkShape,
                    position: new CANNON.Vec3(trunk.position.x, trunk.position.y + 1.5, trunk.position.z)
                });
                
                if (isPhysicsEnabled) {
                    world.add(trunkBody);
                }
                
                // Store tree as camera target
                trunk.userData = { type: 'tree' };
                leaves.userData = { type: 'tree' };
            }
        }
        
        function addCacti(count) {
            const cactusGeometry = new THREE.CylinderGeometry(0.3, 0.5, 2, 8);
            
            for (let i = 0; i < count; i++) {
                const cactusMaterial = new THREE.MeshPhongMaterial({ color: 0x2E8B57 });
                const cactus = new THREE.Mesh(cactusGeometry, cactusMaterial);
                cactus.position.set(
                    (Math.random() - 0.5) * 120, // Increased land size
                    -1,
                    (Math.random() - 0.5) * 120  // Increased land size
                );
                cactus.castShadow = true;
                cactus.receiveShadow = true;
                scene.add(cactus);
                objects.push(cactus);
                
                // Add physics body for cactus
                const cactusShape = new CANNON.Cylinder(0.3, 0.5, 2, 8);
                const cactusBody = new CANNON.Body({
                    mass: 0, // Static body
                    shape: cactusShape,
                    position: new CANNON.Vec3(cactus.position.x, cactus.position.y + 1, cactus.position.z)
                });
                
                if (isPhysicsEnabled) {
                    world.add(cactusBody);
                }
            }
        }
        
        function addRocks(count) {
            for (let i = 0; i < count; i++) {
                const rockGeometry = new THREE.DodecahedronGeometry(Math.random() * 0.8 + 0.2, 0);
                const rockMaterial = new THREE.MeshPhongMaterial({ color: 0xA9A9A9 });
                const rock = new THREE.Mesh(rockGeometry, rockMaterial);
                rock.position.set(
                    (Math.random() - 0.5) * 120, // Increased land size
                    -1.5,
                    (Math.random() - 0.5) * 120  // Increased land size
                );
                rock.rotation.set(
                    Math.random() * Math.PI,
                    Math.random() * Math.PI,
                    Math.random() * Math.PI
                );
                rock.castShadow = true;
                rock.receiveShadow = true;
                scene.add(rock);
                objects.push(rock);
                
                // Add physics body for rock
                const rockShape = new CANNON.Sphere(0.5);
                const rockBody = new CANNON.Body({
                    mass: 0, // Static body
                    shape: rockShape,
                    position: new CANNON.Vec3(rock.position.x, rock.position.y, rock.position.z)
                });
                
                if (isPhysicsEnabled) {
                    world.add(rockBody);
                }
            }
        }
        
        function addSnowmen(count) {
            for (let i = 0; i < count; i++) {
                // Bottom ball
                const bottomGeometry = new THREE.SphereGeometry(0.8, 16, 16);
                const snowMaterial = new THREE.MeshPhongMaterial({ color: 0xFFFFFF });
                const bottom = new THREE.Mesh(bottomGeometry, snowMaterial);
                bottom.position.set(
                    (Math.random() - 0.5) * 90, // Increased land size
                    -1.2,
                    (Math.random() - 0.5) * 90  // Increased land size
                );
                bottom.castShadow = true;
                bottom.receiveShadow = true;
                scene.add(bottom);
                
                // Middle ball
                const middleGeometry = new THREE.SphereGeometry(0.5, 16, 16);
                const middle = new THREE.Mesh(middleGeometry, snowMaterial);
                middle.position.copy(bottom.position);
                middle.position.y += 1;
                middle.castShadow = true;
                middle.receiveShadow = true;
                scene.add(middle);
                
                // Head ball
                const headGeometry = new THREE.SphereGeometry(0.3, 16, 16);
                const head = new THREE.Mesh(headGeometry, snowMaterial);
                head.position.copy(middle.position);
                head.position.y += 0.7;
                head.castShadow = true;
                head.receiveShadow = true;
                scene.add(head);
                
                // Eyes
                const eyeGeometry = new THREE.SphereGeometry(0.05, 8, 8);
                const eyeMaterial = new THREE.MeshPhongMaterial({ color: 0x000000 });
                
                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.copy(head.position);
                leftEye.position.x -= 0.1;
                leftEye.position.y += 0.1;
                leftEye.position.z += 0.25;
                scene.add(leftEye);
                
                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                rightEye.position.copy(head.position);
                rightEye.position.x += 0.1;
                rightEye.position.y += 0.1;
                rightEye.position.z += 0.25;
                scene.add(rightEye);
                
                // Nose
                const noseGeometry = new THREE.ConeGeometry(0.03, 0.1, 8);
                const noseMaterial = new THREE.MeshPhongMaterial({ color: 0xFF4500 });
                const nose = new THREE.Mesh(noseGeometry, noseMaterial);
                nose.position.copy(head.position);
                nose.position.y += 0.05;
                nose.position.z += 0.3;
                nose.rotation.x = Math.PI / 2;
                scene.add(nose);
                
                objects.push(bottom, middle, head, leftEye, rightEye, nose);
                
                // Add physics body for snowman
                const snowmanShape = new CANNON.Sphere(0.8);
                const snowmanBody = new CANNON.Body({
                    mass: 0, // Static body
                    shape: snowmanShape,
                    position: new CANNON.Vec3(bottom.position.x, bottom.position.y + 0.8, bottom.position.z)
                });
                
                if (isPhysicsEnabled) {
                    world.add(snowmanBody);
                }
            }
        }
        
        function addPineTrees(count) {
            const trunkGeometry = new THREE.CylinderGeometry(0.2, 0.3, 2, 8);
            
            for (let i = 0; i < count; i++) {
                // Tree trunk
                const trunkMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                trunk.position.set(
                    (Math.random() - 0.5) * 120, // Increased land size
                    -1,
                    (Math.random() - 0.5) * 120  // Increased land size
                );
                trunk.castShadow = true;
                trunk.receiveShadow = true;
                scene.add(trunk);
                
                // Tree leaves (cone shape)
                const leavesGeometry = new THREE.ConeGeometry(1.5, 3, 8);
                const leavesMaterial = new THREE.MeshPhongMaterial({ color: 0x0F7938 });
                const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
                leaves.position.copy(trunk.position);
                leaves.position.y += 1.5;
                leaves.castShadow = true;
                leaves.receiveShadow = true;
                scene.add(leaves);
                
                objects.push(trunk, leaves);
                
                // Add physics body for pine tree
                const trunkShape = new CANNON.Cylinder(0.2, 0.3, 2, 8);
                const trunkBody = new CANNON.Body({
                    mass: 0, // Static body
                    shape: trunkShape,
                    position: new CANNON.Vec3(trunk.position.x, trunk.position.y + 1, trunk.position.z)
                });
                
                if (isPhysicsEnabled) {
                    world.add(trunkBody);
                }
            }
        }
        
        function addJungleTrees(count) {
            const trunkGeometry = new THREE.CylinderGeometry(0.4, 0.6, 4, 8);
            
            for (let i = 0; i < count; i++) {
                // Tree trunk
                const trunkMaterial = new THREE.MeshPhongMaterial({ color: 0x5D4037 });
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                trunk.position.set(
                    (Math.random() - 0.5) * 120, // Increased land size
                    0,
                    (Math.random() - 0.5) * 120  // Increased land size
                );
                trunk.castShadow = true;
                trunk.receiveShadow = true;
                scene.add(trunk);
                
                // Tree leaves (large sphere)
                const leavesGeometry = new THREE.SphereGeometry(2.5, 8, 6);
                const leavesMaterial = new THREE.MeshPhongMaterial({ color: 0x1B5E20 });
                const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
                leaves.position.copy(trunk.position);
                leaves.position.y += 3;
                leaves.castShadow = true;
                leaves.receiveShadow = true;
                scene.add(leaves);
                
                objects.push(trunk, leaves);
                
                // Add physics body for jungle tree
                const trunkShape = new CANNON.Cylinder(0.4, 0.6, 4, 8);
                const trunkBody = new CANNON.Body({
                    mass: 0, // Static body
                    shape: trunkShape,
                    position: new CANNON.Vec3(trunk.position.x, trunk.position.y + 2, trunk.position.z)
                });
                
                if (isPhysicsEnabled) {
                    world.add(trunkBody);
                }
            }
        }
        
        function addVines(count) {
            for (let i = 0; i < count; i++) {
                const curve = new THREE.CatmullRomCurve3([
                    new THREE.Vector3(
                        (Math.random() - 0.5) * 120, // Increased land size
                        Math.random() * 3,
                        (Math.random() - 0.5) * 120  // Increased land size
                    ),
                    new THREE.Vector3(
                        (Math.random() - 0.5) * 120, // Increased land size
                        Math.random() * 3 + 1,
                        (Math.random() - 0.5) * 120  // Increased land size
                    ),
                    new THREE.Vector3(
                        (Math.random() - 0.5) * 120, // Increased land size
                        Math.random() * 3 + 2,
                        (Math.random() - 0.5) * 120  // Increased land size
                    )
                ]);
                
                const tubeGeometry = new THREE.TubeGeometry(curve, 20, 0.05, 8, false);
                const vineMaterial = new THREE.MeshPhongMaterial({ color: 0x388E3C });
                const vine = new THREE.Mesh(tubeGeometry, vineMaterial);
                vine.castShadow = true;
                vine.receiveShadow = true;
                scene.add(vine);
                objects.push(vine);
            }
        }
        
        function addVolcano() {
            // Create volcano cone
            const volcanoGeometry = new THREE.ConeGeometry(10, 8, 32);
            const volcanoMaterial = new THREE.MeshPhongMaterial({ color: 0x5D4037 });
            const volcano = new THREE.Mesh(volcanoGeometry, volcanoMaterial);
            volcano.position.set(0, -2, 0);
            volcano.castShadow = true;
            volcano.receiveShadow = true;
            scene.add(volcano);
            
            // Create crater
            const craterGeometry = new THREE.CylinderGeometry(3, 2, 1, 32);
            const craterMaterial = new THREE.MeshPhongMaterial({ color: 0x000000 });
            const crater = new THREE.Mesh(craterGeometry, craterMaterial);
            crater.position.copy(volcano.position);
            crater.position.y += 3.5;
            scene.add(crater);
            
            // Create lava
            const lavaGeometry = new THREE.CylinderGeometry(2.8, 0, 0.5, 32);
            const lavaMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xFF5722,
                emissive: 0xFF5722,
                emissiveIntensity: 0.5
            });
            const lava = new THREE.Mesh(lavaGeometry, lavaMaterial);
            lava.position.copy(crater.position);
            lava.position.y -= 0.25;
            scene.add(lava);
            
            objects.push(volcano, crater, lava);
            
            // Add physics body for volcano
            const volcanoShape = new CANNON.Cylinder(10, 0, 8, 32);
            const volcanoBody = new CANNON.Body({
                mass: 0, // Static body
                shape: volcanoShape,
                position: new CANNON.Vec3(0, 2, 0)
            });
            
            if (isPhysicsEnabled) {
                world.add(volcanoBody);
            }
        }
        
        function addLavaRocks(count) {
            for (let i = 0; i < count; i++) {
                const rockGeometry = new THREE.DodecahedronGeometry(Math.random() * 0.8 + 0.2, 0);
                const rockMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x4E342E,
                    emissive: 0xBF360C,
                    emissiveIntensity: 0.2
                });
                const rock = new THREE.Mesh(rockGeometry, rockMaterial);
                rock.position.set(
                    (Math.random() - 0.5) * 120, // Increased land size
                    -1.5,
                    (Math.random() - 0.5) * 120  // Increased land size
                );
                rock.rotation.set(
                    Math.random() * Math.PI,
                    Math.random() * Math.PI,
                    Math.random() * Math.PI
                );
                rock.castShadow = true;
                rock.receiveShadow = true;
                scene.add(rock);
                objects.push(rock);
                
                // Add physics body for lava rock
                const rockShape = new CANNON.Sphere(0.5);
                const rockBody = new CANNON.Body({
                    mass: 0, // Static body
                    shape: rockShape,
                    position: new CANNON.Vec3(rock.position.x, rock.position.y, rock.position.z)
                });
                
                if (isPhysicsEnabled) {
                    world.add(rockBody);
                }
            }
        }
        
        function addPalmTrees(count) {
            const trunkGeometry = new THREE.CylinderGeometry(0.2, 0.3, 4, 8);
            
            for (let i = 0; i < count; i++) {
                // Tree trunk
                const trunkMaterial = new THREE.MeshPhongMaterial({ color: 0x8D6E63 });
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                trunk.position.set(
                    (Math.random() - 0.5) * 120, // Increased land size
                    0,
                    (Math.random() - 0.5) * 120  // Increased land size
                );
                trunk.castShadow = true;
                trunk.receiveShadow = true;
                scene.add(trunk);
                
                // Tree leaves (palm fronds)
                for (let j = 0; j < 6; j++) {
                    const frondGeometry = new THREE.ConeGeometry(0.1, 2, 4);
                    const frondMaterial = new THREE.MeshPhongMaterial({ color: 0x388E3C });
                    const frond = new THREE.Mesh(frondGeometry, frondMaterial);
                    frond.position.copy(trunk.position);
                    frond.position.y += 3.5;
                    frond.rotation.z = Math.PI / 2;
                    frond.rotation.y = (j / 6) * Math.PI * 2;
                    frond.castShadow = true;
                    scene.add(frond);
                    objects.push(frond);
                }
                
                objects.push(trunk);
                
                // Add physics body for palm tree
                const trunkShape = new CANNON.Cylinder(0.2, 0.3, 4, 8);
                const trunkBody = new CANNON.Body({
                    mass: 0, // Static body
                    shape: trunkShape,
                    position: new CANNON.Vec3(trunk.position.x, trunk.position.y + 2, trunk.position.z)
                });
                
                if (isPhysicsEnabled) {
                    world.add(trunkBody);
                }
            }
        }
        
        function addBeachObjects(count) {
            for (let i = 0; i < count; i++) {
                const objectType = Math.floor(Math.random() * 3);
                let object;
                
                switch(objectType) {
                    case 0: // Seashell
                        const shellGeometry = new THREE.SphereGeometry(0.2, 8, 6);
                        shellGeometry.scale(1, 0.5, 1.5);
                        const shellMaterial = new THREE.MeshPhongMaterial({ color: 0xF5F5DC });
                        object = new THREE.Mesh(shellGeometry, shellMaterial);
                        break;
                    case 1: // Beach ball
                        const ballGeometry = new THREE.SphereGeometry(0.3, 16, 16);
                        const ballMaterial = new THREE.MeshPhongMaterial({ color: 0xFF5252 });
                        object = new THREE.Mesh(ballGeometry, ballMaterial);
                        break;
                    case 2: // Starfish
                        const starGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.05, 5);
                        const starMaterial = new THREE.MeshPhongMaterial({ color: 0xFF9800 });
                        object = new THREE.Mesh(starGeometry, starMaterial);
                        break;
                }
                
                object.position.set(
                    (Math.random() - 0.5) * 120, // Increased land size
                    -1.8,
                    (Math.random() - 0.5) * 120  // Increased land size
                );
                object.rotation.set(
                    Math.random() * Math.PI,
                    Math.random() * Math.PI,
                    Math.random() * Math.PI
                );
                object.castShadow = true;
                object.receiveShadow = true;
                scene.add(object);
                objects.push(object);
                
                // Add physics body for beach object
                const objectShape = new CANNON.Sphere(0.3);
                const objectBody = new CANNON.Body({
                    mass: 0, // Static body
                    shape: objectShape,
                    position: new CANNON.Vec3(object.position.x, object.position.y, object.position.z)
                });
                
                if (isPhysicsEnabled) {
                    world.add(objectBody);
                }
            }
        }
        
        function initWeatherSystems() {
            // Create rain particles
            const rainGeometry = new THREE.BufferGeometry();
            const rainCount = 3000; // Reduced for performance
            const rainPositions = new Float32Array(rainCount * 3);
            
            for (let i = 0; i < rainCount * 3; i += 3) {
                rainPositions[i] = (Math.random() - 0.5) * 150; // x - Increased land size
                rainPositions[i + 1] = Math.random() * 50; // y
                rainPositions[i + 2] = (Math.random() - 0.5) * 150; // z - Increased land size
            }
            
            rainGeometry.setAttribute('position', new THREE.BufferAttribute(rainPositions, 3));
            
            const rainMaterial = new THREE.PointsMaterial({
                color: 0xaaaaaa,
                size: 0.1,
                transparent: true
            });
            
            rainParticles = new THREE.Points(rainGeometry, rainMaterial);
            rainParticles.visible = false;
            scene.add(rainParticles);
            
            // Create snow particles
            const snowGeometry = new THREE.BufferGeometry();
            const snowCount = 2000; // Reduced for performance
            const snowPositions = new Float32Array(snowCount * 3);
            const snowSizes = new Float32Array(snowCount);
            
            for (let i = 0; i < snowCount * 3; i += 3) {
                snowPositions[i] = (Math.random() - 0.5) * 150; // x - Increased land size
                snowPositions[i + 1] = Math.random() * 50; // y
                snowPositions[i + 2] = (Math.random() - 0.5) * 150; // z - Increased land size
                snowSizes[i / 3] = Math.random() * 0.2 + 0.1;
            }
            
            snowGeometry.setAttribute('position', new THREE.BufferAttribute(snowPositions, 3));
            snowGeometry.setAttribute('size', new THREE.BufferAttribute(snowSizes, 1));
            
            const snowMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.2,
                transparent: true,
                sizeAttenuation: true
            });
            
            snowParticles = new THREE.Points(snowGeometry, snowMaterial);
            snowParticles.visible = false;
            scene.add(snowParticles);
        }
        
        function setupControls() {
            // Toggle physics button
            document.getElementById('togglePhysics').addEventListener('click', function() {
                isPhysicsEnabled = !isPhysicsEnabled;
                this.textContent = isPhysicsEnabled ? 'Disable Physics' : 'Enable Physics';
                this.classList.toggle('active');
                updateModeDisplay();
                
                if (isPhysicsEnabled) {
                    enablePhysics();
                } else {
                    disablePhysics();
                }
            });
            
            // Toggle rain button
            document.getElementById('toggleRain').addEventListener('click', function() {
                isRaining = !isRaining;
                this.textContent = isRaining ? 'Stop Rain' : 'Rain Mode';
                this.classList.toggle('active');
                
                if (isRaining) {
                    rainParticles.visible = true;
                    makeEverythingWet();
                    // Remove snow if it's active
                    if (isSnowing) {
                        isSnowing = false;
                        snowParticles.visible = false;
                        document.getElementById('toggleSnow').textContent = 'Snow Mode';
                        document.getElementById('toggleSnow').classList.remove('active');
                        removeSnowFromGround();
                    }
                } else {
                    rainParticles.visible = false;
                    dryEverything();
                }
                updateModeDisplay();
            });
            
            // Toggle snow button
            document.getElementById('toggleSnow').addEventListener('click', function() {
                isSnowing = !isSnowing;
                this.textContent = isSnowing ? 'Stop Snow' : 'Snow Mode';
                this.classList.toggle('active');
                
                if (isSnowing) {
                    snowParticles.visible = true;
                    // Disable rain if it's active
                    if (isRaining) {
                        isRaining = false;
                        rainParticles.visible = false;
                        document.getElementById('toggleRain').textContent = 'Rain Mode';
                        document.getElementById('toggleRain').classList.remove('active');
                        dryEverything();
                    }
                    
                    // Make humans wear jackets
                    updateHumanClothingForSnow();
                } else {
                    snowParticles.visible = false;
                    
                    // Remove jackets from humans
                    removeJacketsFromHumans();
                }
                updateModeDisplay();
            });
            
            // Toggle day/night cycle button
            document.getElementById('toggleDayNight').addEventListener('click', function() {
                isDayNightCycle = !isDayNightCycle;
                this.textContent = isDayNightCycle ? 'Stop Day/Night' : 'Day/Night Cycle';
                this.classList.toggle('active');
                updateModeDisplay();
            });
            
            // Biome buttons
            document.getElementById('biomeForest').addEventListener('click', () => {
                createBiome('forest');
            });
            
            document.getElementById('biomeDesert').addEventListener('click', () => {
                createBiome('desert');
            });
            
            document.getElementById('biomeSnow').addEventListener('click', () => {
                createBiome('snow');
            });
            
            document.getElementById('biomeJungle').addEventListener('click', () => {
                createBiome('jungle');
            });
            
            document.getElementById('biomeVolcano').addEventListener('click', () => {
                createBiome('volcano');
            });
            
            document.getElementById('biomeIsland').addEventListener('click', () => {
                createBiome('island');
            });
            
            document.getElementById('biomeTown').addEventListener('click', () => {
                createBiome('town');
            });
            
            document.getElementById('biomeMaze').addEventListener('click', () => {
                createBiome('maze');
            });
            
            document.getElementById('biomeLuxury').addEventListener('click', () => {
                createBiome('luxury');
            });
            
            // Add object button
            document.getElementById('addObject').addEventListener('click', () => {
                const geometries = [
                    new THREE.BoxGeometry(0.5, 0.5, 0.5),
                    new THREE.SphereGeometry(0.5, 32, 32),
                    new THREE.ConeGeometry(0.5, 1, 32),
                    new THREE.CylinderGeometry(0.5, 0.5, 1, 32),
                    new THREE.TorusGeometry(0.5, 0.2, 16, 100)
                ];
                
                const randomGeometry = geometries[Math.floor(Math.random() * geometries.length)];
                const material = new THREE.MeshPhongMaterial({ 
                    color: Math.random() * 0xffffff 
                });
                
                const newObject = new THREE.Mesh(randomGeometry, material);
                
                // Position object based on current mode
                if (isFirstPersonMode) {
                    // Position in front of player
                    const direction = new THREE.Vector3();
                    camera.getWorldDirection(direction);
                    
                    newObject.position.copy(camera.position);
                    newObject.position.add(direction.multiplyScalar(3));
                    newObject.position.y -= 1; // Adjust height
                } else {
                    // Random position
                    newObject.position.set(
                        (Math.random() - 0.5) * 10,
                        Math.random() * 2 + 3,
                        (Math.random() - 0.5) * 10
                    );
                }
                
                newObject.castShadow = true;
                newObject.receiveShadow = true;
                newObject.userData = { draggable: true };
                
                scene.add(newObject);
                objects.push(newObject);
                
                // Add physics body if physics is enabled
                if (isPhysicsEnabled) {
                    addPhysicsBody(newObject);
                }
            });
            
            // Spawn human button
            document.getElementById('spawnHuman').addEventListener('click', () => {
                spawnAdvancedHuman();
            });
            
            // Spawn multiple humans button
            document.getElementById('spawnMultipleHumans').addEventListener('click', () => {
                for (let i = 0; i < 5; i++) {
                    setTimeout(() => {
                        spawnAdvancedHuman();
                    }, i * 200);
                }
            });
            
            // Spawn gun button
            document.getElementById('spawnGun').addEventListener('click', () => {
                spawnGun();
            });
            
            // Spawn multiple guns button
            document.getElementById('spawnMultipleGuns').addEventListener('click', () => {
                for (let i = 0; i < 5; i++) {
                    setTimeout(() => {
                        spawnGun();
                    }, i * 200);
                }
            });
            
            // Spawn ragdoll button
            document.getElementById('spawnRagdoll').addEventListener('click', () => {
                spawnRagdoll();
            });
            
            // Toggle aggression button
            document.getElementById('toggleAggression').addEventListener('click', function() {
                aiAggression = !aiAggression;
                this.textContent = aiAggression ? 'Disable Aggression' : 'Enable Aggression';
                this.classList.toggle('active');
                document.getElementById('aggressionLevel').textContent = aiAggression ? 'High' : 'Low';
            });
            
            // Toggle interactions button
            document.getElementById('toggleInteractions').addEventListener('click', function() {
                aiInteractions = !aiInteractions;
                this.textContent = aiInteractions ? 'Disable Interactions' : 'Enable Interactions';
                this.classList.toggle('active');
            });
            
            // Toggle speech button
            document.getElementById('toggleSpeech').addEventListener('click', function() {
                aiSpeech = !aiSpeech;
                this.textContent = aiSpeech ? 'Disable Speech' : 'Enable Speech';
                this.classList.toggle('active');
            });
            
            // AI speed slider
            document.getElementById('aiSpeedSlider').addEventListener('input', (e) => {
                aiSpeed = parseFloat(e.target.value);
            });
            
            // Rain intensity slider
            document.getElementById('rainIntensitySlider').addEventListener('input', (e) => {
                rainIntensity = parseFloat(e.target.value);
            });
            
            // Reset scene button
            document.getElementById('resetScene').addEventListener('click', () => {
                // Stop any ongoing recording
                if (isRecording) {
                    stopRecording();
                }
                
                // Exit first person mode if active
                if (isFirstPersonMode) {
                    toggleFirstPersonMode();
                }
                
                // Remove all objects except ground
                objects.forEach(obj => {
                    scene.remove(obj);
                });
                
                // Remove physics bodies
                physicsObjects.forEach(body => {
                    world.remove(body);
                });
                
                // Remove AI humans
                aiHumans.forEach(human => {
                    scene.remove(human.mesh);
                    world.remove(human.body);
                    
                    // Remove health bar
                    if (human.healthBarElement) {
                        healthBarsContainer.removeChild(human.healthBarElement);
                    }
                    
                    // Remove interaction indicators
                    if (human.interactionElement) {
                        healthBarsContainer.removeChild(human.interactionElement);
                    }
                    
                    // Remove speech bubble
                    if (human.speechBubbleElement) {
                        healthBarsContainer.removeChild(human.speechBubbleElement);
                    }
                    
                    // Remove emotion indicator
                    if (human.emotionElement) {
                        healthBarsContainer.removeChild(human.emotionElement);
                    }
                });
                
                // Remove guns
                guns.forEach(gun => {
                    scene.remove(gun.mesh);
                    world.remove(gun.body);
                });
                
                // Remove bullets
                bullets.forEach(bullet => {
                    scene.remove(bullet.mesh);
                    world.remove(bullet.body);
                });
                
                // Remove ragdolls
                ragdolls.forEach(ragdoll => {
                    ragdoll.parts.forEach(part => {
                        scene.remove(part.mesh);
                        world.remove(part.body);
                    });
                    ragdoll.constraints.forEach(constraint => {
                        world.remove(constraint);
                    });
                });
                
                // Remove snow from ground
                snowOnGround.forEach(snow => {
                    scene.remove(snow);
                });
                
                // Remove water
                waterMeshes.forEach(water => {
                    scene.remove(water);
                });
                
                // Remove grass
                grassBlades.forEach(blade => {
                    scene.remove(blade);
                });
                
                // Remove maze walls
                mazeWalls.forEach(wall => {
                    scene.remove(wall.mesh);
                    if (isPhysicsEnabled && wall.body) {
                        world.remove(wall.body);
                    }
                });
                
                // Remove luxury houses
                if (window.luxuryHouses) {
                    window.luxuryHouses.forEach(house => {
                        scene.remove(house.mesh);
                        if (isPhysicsEnabled && house.body) {
                            world.remove(house.body);
                        }
                    });
                    window.luxuryHouses = [];
                }
                
                objects = [];
                physicsObjects = [];
                aiHumans = [];
                guns = [];
                bullets = [];
                ragdolls = [];
                snowOnGround = [];
                wetMaterials = [];
                waterMeshes = [];
                mazeWalls = [];
                grassBlades = [];
                
                // Reset modes
                isPhysicsEnabled = false;
                isRaining = false;
                isSnowing = false;
                isDayNightCycle = false;
                
                // Reset water
                initWaterGrid();
                waterLevel = 0;
                updateWaterLevelDisplay();
                floodWarningShown = false;
                document.getElementById('floodWarning').style.display = 'none';
                
                // Update UI
                document.getElementById('togglePhysics').textContent = 'Enable Physics';
                document.getElementById('togglePhysics').classList.remove('active');
                document.getElementById('toggleRain').textContent = 'Rain Mode';
                document.getElementById('toggleRain').classList.remove('active');
                document.getElementById('toggleSnow').textContent = 'Snow Mode';
                document.getElementById('toggleSnow').classList.remove('active');
                document.getElementById('toggleDayNight').textContent = 'Day/Night Cycle';
                document.getElementById('toggleDayNight').classList.remove('active');
                document.getElementById('toggleAggression').textContent = 'Enable Aggression';
                document.getElementById('toggleAggression').classList.remove('active');
                document.getElementById('toggleInteractions').textContent = 'Enable Interactions';
                document.getElementById('toggleInteractions').classList.remove('active');
                document.getElementById('toggleSpeech').textContent = 'Enable Speech';
                document.getElementById('toggleSpeech').classList.remove('active');
                
                rainParticles.visible = false;
                snowParticles.visible = false;
                
                // Reset time
                currentTime = 12;
                updateDayNightCycle();
                
                // Recreate the scene
                createObjects();
                updateStats();
                updateModeDisplay();
                
                // Update camera targets if auto camera is enabled
                if (autoCameraEnabled) {
                    updateCameraTargets();
                }
            });
            
            // Time speed slider
            document.getElementById('timeSpeedSlider').addEventListener('input', (e) => {
                dayNightSpeed = parseFloat(e.target.value);
            });
        }
        
        function enablePhysics() {
            // Add physics bodies to existing objects
            objects.forEach(obj => {
                if (obj.userData.draggable) {
                    addPhysicsBody(obj);
                }
            });
            
            // Add physics to AI humans
            aiHumans.forEach(human => {
                world.add(human.body);
            });
            
            // Add physics to guns
            guns.forEach(gun => {
                world.add(gun.body);
            });
            
            // Add physics to bullets
            bullets.forEach(bullet => {
                world.add(bullet.body);
            });
            
            // Add physics to ragdolls
            ragdolls.forEach(ragdoll => {
                ragdoll.parts.forEach(part => {
                    world.add(part.body);
                });
                ragdoll.constraints.forEach(constraint => {
                    world.add(constraint);
                });
            });
            
            // Add physics to maze walls
            mazeWalls.forEach(wall => {
                if (wall.body) {
                    world.add(wall.body);
                }
            });
            
            // Add physics to luxury houses
            if (window.luxuryHouses) {
                window.luxuryHouses.forEach(house => {
                    if (house.body) {
                        world.add(house.body);
                    }
                });
            }
            
            // Add physics to grass blades
            grassBlades.forEach(blade => {
                if (blade.userData.body) {
                    world.add(blade.userData.body);
                }
            });
            
            // Add physics to player body if in first person mode
            if (isFirstPersonMode && playerBody) {
                world.add(playerBody);
            }
        }
        
        function disablePhysics() {
            // Remove all physics bodies
            physicsObjects.forEach(body => {
                world.remove(body);
            });
            physicsObjects = [];
            
            // Remove physics from AI humans
            aiHumans.forEach(human => {
                world.remove(human.body);
            });
            
            // Remove physics from guns
            guns.forEach(gun => {
                world.remove(gun.body);
            });
            
            // Remove physics from bullets
            bullets.forEach(bullet => {
                world.remove(bullet.body);
            });
            
            // Remove physics from ragdolls
            ragdolls.forEach(ragdoll => {
                ragdoll.parts.forEach(part => {
                    world.remove(part.body);
                });
                ragdoll.constraints.forEach(constraint => {
                    world.remove(constraint);
                });
            });
            
            // Remove physics from maze walls
            mazeWalls.forEach(wall => {
                if (wall.body) {
                    world.remove(wall.body);
                }
            });
            
            // Remove physics from luxury houses
            if (window.luxuryHouses) {
                window.luxuryHouses.forEach(house => {
                    if (house.body) {
                        world.remove(house.body);
                    }
                });
            }
            
            // Remove physics from grass blades
            grassBlades.forEach(blade => {
                if (blade.userData.body) {
                    world.remove(blade.userData.body);
                }
            });
            
            // Remove physics from player body if in first person mode
            if (isFirstPersonMode && playerBody) {
                world.remove(playerBody);
            }
        }
        
        function addPhysicsBody(mesh) {
            let shape;
            
            // Determine shape based on geometry type
            if (mesh.geometry.type === 'BoxGeometry') {
                const size = mesh.geometry.parameters;
                shape = new CANNON.Box(new CANNON.Vec3(size.width/2, size.height/2, size.depth/2));
            } else if (mesh.geometry.type === 'SphereGeometry') {
                shape = new CANNON.Sphere(mesh.geometry.parameters.radius);
            } else if (mesh.geometry.type === 'ConeGeometry') {
                shape = new CANNON.Sphere(mesh.geometry.parameters.radiusBottom); // Approximate with sphere
            } else if (mesh.geometry.type === 'CylinderGeometry') {
                shape = new CANNON.Box(new CANNON.Vec3(
                    mesh.geometry.parameters.radiusTop,
                    mesh.geometry.parameters.height/2,
                    mesh.geometry.parameters.radiusTop
                )); // Approximate with box
            } else if (mesh.geometry.type === 'TorusGeometry') {
                shape = new CANNON.Sphere(mesh.geometry.parameters.radius); // Approximate with sphere
            } else {
                // Default to sphere
                shape = new CANNON.Sphere(0.5);
            }
            
            const body = new CANNON.Body({
                mass: 1, // Dynamic body
                shape: shape,
                position: new CANNON.Vec3(mesh.position.x, mesh.position.y, mesh.position.z)
            });
            
            world.add(body);
            physicsObjects.push(body);
            
            // Store reference to mesh for updating
            body.mesh = mesh;
        }
        
        function spawnAdvancedHuman() {
            // Create a more realistic human model
            const humanGroup = new THREE.Group();
            
            // Randomly determine gender
            const isMale = Math.random() > 0.5;
            
            // Randomly select skin tone
            const skinTone = skinTones[Math.floor(Math.random() * skinTones.length)];
            
            // Randomly select hair style and color
            const hairStyle = hairStyles[Math.floor(Math.random() * hairStyles.length)];
            const hairColor = hairColors[Math.floor(Math.random() * hairColors.length)];
            
            // Randomly select clothing style and color
            const clothingStyle = clothingStyles[Math.floor(Math.random() * clothingStyles.length)];
            const clothingColor = clothingColors[Math.floor(Math.random() * clothingColors.length)];
            
            // Create body parts with more realistic proportions
            // Head
            const headGeometry = new THREE.SphereGeometry(0.3, 32, 32);
            const headMaterial = new THREE.MeshPhongMaterial({ 
                color: skinTone,
                skinTone: skinTone // Store skin tone for later reference
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.7;
            head.castShadow = true;
            humanGroup.add(head);
            
            // Add facial features
            // Eyes
            const eyeGeometry = new THREE.SphereGeometry(0.05, 8, 8);
            const eyeMaterial = new THREE.MeshPhongMaterial({ color: 0x000000 });
            
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.1, 1.75, 0.25);
            humanGroup.add(leftEye);
            
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.1, 1.75, 0.25);
            humanGroup.add(rightEye);
            
            // Nose
            const noseGeometry = new THREE.ConeGeometry(0.03, 0.1, 8);
            const noseMaterial = new THREE.MeshPhongMaterial({ color: skinTone });
            const nose = new THREE.Mesh(noseGeometry, noseMaterial);
            nose.position.set(0, 1.7, 0.3);
            nose.rotation.x = Math.PI / 2;
            humanGroup.add(nose);
            
            // Mouth
            const mouthGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.1, 8);
            const mouthMaterial = new THREE.MeshPhongMaterial({ color: 0x8B0000 });
            const mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
            mouth.position.set(0, 1.6, 0.25);
            mouth.rotation.x = Math.PI / 2;
            humanGroup.add(mouth);
            
            // Hair based on style
            let hair = null;
            if (hairStyle !== 'bald') {
                let hairGeometry;
                
                switch(hairStyle) {
                    case 'short':
                        hairGeometry = new THREE.SphereGeometry(0.32, 16, 16);
                        break;
                    case 'medium':
                        hairGeometry = new THREE.SphereGeometry(0.35, 16, 16);
                        break;
                    case 'long':
                        hairGeometry = new THREE.SphereGeometry(0.4, 16, 16);
                        break;
                    case 'curly':
                        hairGeometry = new THREE.SphereGeometry(0.38, 16, 16);
                        break;
                    case 'ponytail':
                        hairGeometry = new THREE.SphereGeometry(0.32, 16, 16);
                        break;
                    case 'braids':
                        hairGeometry = new THREE.SphereGeometry(0.34, 16, 16);
                        break;
                    case 'afro':
                        hairGeometry = new THREE.SphereGeometry(0.45, 16, 16);
                        break;
                    case 'mohawk':
                        hairGeometry = new THREE.BoxGeometry(0.05, 0.3, 0.4);
                        break;
                    case 'buzzcut':
                        hairGeometry = new THREE.SphereGeometry(0.31, 16, 16);
                        break;
                    case 'undercut':
                        hairGeometry = new THREE.SphereGeometry(0.33, 16, 16);
                        break;
                    case 'bob':
                        hairGeometry = new THREE.SphereGeometry(0.36, 16, 16);
                        break;
                    case 'pixie':
                        hairGeometry = new THREE.SphereGeometry(0.34, 16, 16);
                        break;
                    case 'dreadlocks':
                        hairGeometry = new THREE.SphereGeometry(0.37, 16, 16);
                        break;
                    case 'waves':
                        hairGeometry = new THREE.SphereGeometry(0.35, 16, 16);
                        break;
                    case 'straight':
                        hairGeometry = new THREE.SphereGeometry(0.34, 16, 16);
                        break;
                }
                
                const hairMaterial = new THREE.MeshPhongMaterial({ 
                    color: hairColor,
                    hairColor: hairColor // Store hair color for later reference
                });
                hair = new THREE.Mesh(hairGeometry, hairMaterial);
                hair.position.y = 1.85;
                hair.castShadow = true;
                humanGroup.add(hair);
                
                // Add additional hair elements for certain styles
                if (hairStyle === 'ponytail') {
                    const ponytailGeometry = new THREE.CylinderGeometry(0.08, 0.12, 0.4, 8);
                    const ponytail = new THREE.Mesh(ponytailGeometry, hairMaterial);
                    ponytail.position.set(0, 1.6, -0.3);
                    ponytail.rotation.x = Math.PI / 4;
                    humanGroup.add(ponytail);
                } else if (hairStyle === 'braids') {
                    for (let i = 0; i < 2; i++) {
                        const braidGeometry = new THREE.CylinderGeometry(0.05, 0.07, 0.5, 8);
                        const braid = new THREE.Mesh(braidGeometry, hairMaterial);
                        braid.position.set(i === 0 ? -0.15 : 0.15, 1.5, -0.2);
                        braid.rotation.x = Math.PI / 4;
                        humanGroup.add(braid);
                    }
                } else if (hairStyle === 'mohawk') {
                    for (let i = 0; i < 5; i++) {
                        const spikeGeometry = new THREE.ConeGeometry(0.03, 0.2, 8);
                        const spike = new THREE.Mesh(spikeGeometry, hairMaterial);
                        spike.position.set((i - 2) * 0.05, 1.95, 0);
                        spike.rotation.x = Math.PI / 2;
                        humanGroup.add(spike);
                    }
                } else if (hairStyle === 'dreadlocks') {
                    for (let i = 0; i < 8; i++) {
                        const dreadlockGeometry = new THREE.CylinderGeometry(0.03, 0.04, 0.4, 8);
                        const dreadlock = new THREE.Mesh(dreadlockGeometry, hairMaterial);
                        const angle = (i / 8) * Math.PI * 2;
                        dreadlock.position.set(
                            Math.cos(angle) * 0.25,
                            1.7,
                            Math.sin(angle) * 0.25
                        );
                        dreadlock.rotation.z = angle;
                        humanGroup.add(dreadlock);
                    }
                }
            }
            
            // Body with gender-specific proportions
            let bodyWidth, bodyDepth;
            if (isMale) {
                bodyWidth = 0.4;
                bodyDepth = 0.3;
            } else {
                bodyWidth = 0.35;
                bodyDepth = 0.25;
            }
            
            const bodyGeometry = new THREE.CylinderGeometry(bodyDepth * 0.8, bodyWidth, 1.2, 16);
            const bodyMaterial = new THREE.MeshPhongMaterial({ 
                color: clothingColor,
                clothingColor: clothingColor // Store clothing color for later reference
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.9;
            body.castShadow = true;
            humanGroup.add(body);
            
            // Arms with gender-specific proportions
            let armWidth;
            if (isMale) {
                armWidth = 0.12;
            } else {
                armWidth = 0.1;
            }
            
            const armGeometry = new THREE.CylinderGeometry(armWidth, armWidth, 0.8, 8);
            const armMaterial = new THREE.MeshPhongMaterial({ color: skinTone });
            
            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(-bodyWidth - 0.1, 1.1, 0);
            leftArm.rotation.z = Math.PI / 6;
            leftArm.castShadow = true;
            humanGroup.add(leftArm);
            
            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.set(bodyWidth + 0.1, 1.1, 0);
            rightArm.rotation.z = -Math.PI / 6;
            rightArm.castShadow = true;
            humanGroup.add(rightArm);
            
            // Legs with gender-specific proportions
            let legWidth;
            if (isMale) {
                legWidth = 0.14;
            } else {
                legWidth = 0.12;
            }
            
            const legGeometry = new THREE.CylinderGeometry(legWidth, legWidth, 1.2, 8);
            const legMaterial = new THREE.MeshPhongMaterial({ color: 0x2E4057 });
            
            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-bodyWidth * 0.6, 0.1, 0);
            leftLeg.castShadow = true;
            humanGroup.add(leftLeg);
            
            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(bodyWidth * 0.6, 0.1, 0);
            rightLeg.castShadow = true;
            humanGroup.add(rightLeg);
            
            // Add jacket if in snow biome or if it's snowing
            let jacket = null;
            if (currentBiome === 'snow' || isSnowing) {
                const jacketColor = jacketColors[Math.floor(Math.random() * jacketColors.length)];
                const jacketGeometry = new THREE.BoxGeometry(bodyWidth * 1.1, 1.0, bodyDepth * 1.1);
                const jacketMaterial = new THREE.MeshPhongMaterial({ 
                    color: jacketColor,
                    jacketColor: jacketColor // Store jacket color for later reference
                });
                jacket = new THREE.Mesh(jacketGeometry, jacketMaterial);
                jacket.position.y = 0.9;
                jacket.castShadow = true;
                humanGroup.add(jacket);
                
                // Add jacket hood
                const hoodGeometry = new THREE.SphereGeometry(0.35, 16, 16);
                const hoodMaterial = new THREE.MeshPhongMaterial({ color: jacketColor });
                const hood = new THREE.Mesh(hoodGeometry, hoodMaterial);
                hood.position.set(0, 1.7, 0);
                hood.scale.set(1.2, 0.8, 1.2);
                hood.castShadow = true;
                humanGroup.add(hood);
            }
            
            // Position the human
            humanGroup.position.set(
                (Math.random() - 0.5) * 60,
                0,
                (Math.random() - 0.5) * 60
            );
            
            scene.add(humanGroup);
            objects.push(humanGroup);
            
            // Create physics body for the human
            const humanShape = new CANNON.Box(new CANNON.Vec3(bodyWidth, 1.7, bodyWidth));
            const humanBody = new CANNON.Body({
                mass: 70, // Average human weight in kg
                shape: humanShape,
                position: new CANNON.Vec3(
                    humanGroup.position.x,
                    humanGroup.position.y + 0.85,
                    humanGroup.position.z
                )
            });
            
            if (isPhysicsEnabled) {
                world.add(humanBody);
            }
            
            // Create health bar
            const healthBarContainer = document.createElement('div');
            healthBarContainer.className = 'health-bar-container';
            healthBarContainer.style.width = '40px';
            healthBarContainer.style.height = '4px';
            
            const healthBar = document.createElement('div');
            healthBar.className = 'health-bar';
            healthBar.style.width = '100%';
            healthBarContainer.appendChild(healthBar);
            
            healthBarsContainer.appendChild(healthBarContainer);
            
            // Create interaction indicator
            const interactionIndicator = document.createElement('div');
            interactionIndicator.className = 'interaction-indicator';
            interactionIndicator.style.display = 'none';
            healthBarsContainer.appendChild(interactionIndicator);
            
            // Create speech bubble
            const speechBubble = document.createElement('div');
            speechBubble.className = 'speech-bubble';
            speechBubble.style.display = 'none';
            healthBarsContainer.appendChild(speechBubble);
            
            // Create emotion indicator
            const emotionIndicator = document.createElement('div');
            emotionIndicator.className = 'emotion-indicator';
            emotionIndicator.textContent = '😊';
            emotionIndicator.style.display = 'none';
            healthBarsContainer.appendChild(emotionIndicator);
            
            // Randomly select initial emotion
            const initialEmotion = emotions[Math.floor(Math.random() * emotions.length)];
            
            // Create advanced AI human object
            const aiHuman = {
                mesh: humanGroup,
                body: humanBody,
                isMale: isMale,
                skinTone: skinTone,
                hairStyle: hairStyle,
                hairColor: hairColor,
                clothingStyle: clothingStyle,
                clothingColor: clothingColor,
                jacket: jacket,
                jacketColor: jacket ? jacket.material.color.getHex() : null,
                head: head,
                hair: hair,
                body: body,
                leftArm: leftArm,
                rightArm: rightArm,
                leftLeg: leftLeg,
                rightLeg: rightLeg,
                state: 'wandering', // wandering, seeking, attacking, fleeing, interacting, entering, inside, exiting
                targetPosition: new THREE.Vector3(
                    (Math.random() - 0.5) * 60,
                    0,
                    (Math.random() - 0.5) * 60
                ),
                targetHuman: null,
                targetGun: null,
                targetBuilding: null,
                heldGun: null,
                speed: aiSpeed + Math.random() * 0.05,
                health: 100, // FIXED: Initialize health to 100%
                maxHealth: 100,
                thinkTimer: 0,
                shootTimer: 0,
                accuracy: 0.5 + Math.random() * 0.4, // Accuracy between 0.5 and 0.9
                aggression: 0.3 + Math.random() * 0.7, // Aggression between 0.3 and 1.0
                sociability: 0.3 + Math.random() * 0.7, // Sociability between 0.3 and 1.0
                relationships: {}, // Relationships with other humans
                healthBarElement: healthBarContainer,
                healthBar: healthBar,
                interactionElement: interactionIndicator,
                speechBubbleElement: speechBubble,
                emotionElement: emotionIndicator,
                interactionTimer: 0,
                speechTimer: 0,
                emotionTimer: 0,
                currentEmotion: initialEmotion,
                animationTimer: 0,
                animationState: 'idle', // idle, walking, running, interacting, etc.
                insideBuilding: null,
                buildingExitTimer: 0,
                hunger: 50 + Math.random() * 50, // Hunger level (0-100)
                thirst: 50 + Math.random() * 50, // Thirst level (0-100)
                energy: 50 + Math.random() * 50, // Energy level (0-100)
                lastPosition: humanGroup.position.clone(), // For collision detection
                stuckTimer: 0, // Timer to detect if human is stuck
                aiDecisionTimer: 0 // Timer for AI decision making
            };
            
            aiHumans.push(aiHuman);
            updateStats();
            
            // Show initial emotion briefly
            showEmotion(aiHuman, initialEmotion, 2000);
            
            // Update camera targets if auto camera is enabled
            if (autoCameraEnabled) {
                updateCameraTargets();
            }
        }
        
        function updateHumanClothingForSnow() {
            // Make all existing humans wear jackets
            aiHumans.forEach(human => {
                if (!human.jacket) {
                    // Add jacket
                    const jacketColor = jacketColors[Math.floor(Math.random() * jacketColors.length)];
                    const jacketGeometry = new THREE.BoxGeometry(0.44, 1.0, 0.33);
                    const jacketMaterial = new THREE.MeshPhongMaterial({ 
                        color: jacketColor,
                        jacketColor: jacketColor // Store jacket color for later reference
                    });
                    const jacket = new THREE.Mesh(jacketGeometry, jacketMaterial);
                    jacket.position.y = 0.9;
                    jacket.castShadow = true;
                    human.mesh.add(jacket);
                    
                    // Add jacket hood
                    const hoodGeometry = new THREE.SphereGeometry(0.35, 16, 16);
                    const hoodMaterial = new THREE.MeshPhongMaterial({ color: jacketColor });
                    const hood = new THREE.Mesh(hoodGeometry, hoodMaterial);
                    hood.position.set(0, 1.7, 0);
                    hood.scale.set(1.2, 0.8, 1.2);
                    hood.castShadow = true;
                    human.mesh.add(hood);
                    
                    // Store jacket reference
                    human.jacket = jacket;
                    human.jacketColor = jacketColor;
                    human.hood = hood;
                }
            });
        }
        
        function removeJacketsFromHumans() {
            // Remove jackets from all humans
            aiHumans.forEach(human => {
                if (human.jacket) {
                    human.mesh.remove(human.jacket);
                    human.mesh.remove(human.hood);
                    human.jacket = null;
                    human.jacketColor = null;
                    human.hood = null;
                }
            });
        }
        
        function spawnGun() {
            // Create a simple gun model
            const gunGroup = new THREE.Group();
            
            // Gun barrel
            const barrelGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.5, 8);
            const barrelMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
            const barrel = new THREE.Mesh(barrelGeometry, barrelMaterial);
            barrel.rotation.z = Math.PI / 2;
            barrel.position.x = 0.25;
            barrel.castShadow = true;
            gunGroup.add(barrel);
            
            // Gun body
            const bodyGeometry = new THREE.BoxGeometry(0.3, 0.15, 0.1);
            const bodyMaterial = new THREE.MeshPhongMaterial({ color: 0x222222 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.castShadow = true;
            gunGroup.add(body);
            
            // Gun grip
            const gripGeometry = new THREE.BoxGeometry(0.1, 0.2, 0.1);
            const gripMaterial = new THREE.MeshPhongMaterial({ color: 0x444444 });
            const grip = new THREE.Mesh(gripGeometry, gripMaterial);
            grip.position.y = -0.15;
            grip.castShadow = true;
            gunGroup.add(grip);
            
            // Position the gun
            if (isFirstPersonMode) {
                // Position in front of player
                const direction = new THREE.Vector3();
                camera.getWorldDirection(direction);
                
                gunGroup.position.copy(camera.position);
                gunGroup.position.add(direction.multiplyScalar(2));
                gunGroup.position.y -= 1; // Adjust height
            } else {
                // Random position
                gunGroup.position.set(
                    (Math.random() - 0.5) * 60,
                    1,
                    (Math.random() - 0.5) * 60
                );
            }
            
            scene.add(gunGroup);
            objects.push(gunGroup);
            
            // Create physics body for the gun
            const gunShape = new CANNON.Box(new CANNON.Vec3(0.3, 0.15, 0.1));
            const gunBody = new CANNON.Body({
                mass: 1, // Gun weight
                shape: gunShape,
                position: new CANNON.Vec3(
                    gunGroup.position.x,
                    gunGroup.position.y,
                    gunGroup.position.z
                )
            });
            
            if (isPhysicsEnabled) {
                world.add(gunBody);
            }
            
            // Create gun object
            const gun = {
                mesh: gunGroup,
                body: gunBody,
                isHeld: false,
                holder: null,
                ammo: 30,
                lastShotTime: 0
            };
            
            guns.push(gun);
            updateStats();
            
            // Update camera targets if auto camera is enabled
            if (autoCameraEnabled) {
                updateCameraTargets();
            }
        }
        
        function spawnRagdoll() {
            const ragdoll = {
                parts: [],
                constraints: []
            };
            
            // Create ragdoll parts
            const partSize = 0.2;
            const ragdollMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff });
            
            // Head
            const headGeometry = new THREE.SphereGeometry(partSize * 1.5, 16, 16);
            const headMesh = new THREE.Mesh(headGeometry, ragdollMaterial);
            headMesh.castShadow = true;
            scene.add(headMesh);
            
            const headShape = new CANNON.Sphere(partSize * 1.5);
            const headBody = new CANNON.Body({
                mass: 5,
                shape: headShape
            });
            
            if (isPhysicsEnabled) {
                world.add(headBody);
            }
            
            ragdoll.parts.push({
                mesh: headMesh,
                body: headBody,
                type: 'head'
            });
            
            // Torso
            const torsoGeometry = new THREE.BoxGeometry(partSize * 2, partSize * 3, partSize);
            const torsoMesh = new THREE.Mesh(torsoGeometry, ragdollMaterial);
            torsoMesh.castShadow = true;
            scene.add(torsoMesh);
            
            const torsoShape = new CANNON.Box(new CANNON.Vec3(partSize, partSize * 1.5, partSize * 0.5));
            const torsoBody = new CANNON.Body({
                mass: 15,
                shape: torsoShape
            });
            
            if (isPhysicsEnabled) {
                world.add(torsoBody);
            }
            
            ragdoll.parts.push({
                mesh: torsoMesh,
                body: torsoBody,
                type: 'torso'
            });
            
            // Arms
            for (let i = 0; i < 2; i++) {
                const side = i === 0 ? -1 : 1;
                
                // Upper arm
                const upperArmGeometry = new THREE.BoxGeometry(partSize * 0.8, partSize * 1.5, partSize * 0.8);
                const upperArmMesh = new THREE.Mesh(upperArmGeometry, ragdollMaterial);
                upperArmMesh.castShadow = true;
                scene.add(upperArmMesh);
                
                const upperArmShape = new CANNON.Box(new CANNON.Vec3(partSize * 0.4, partSize * 0.75, partSize * 0.4));
                const upperArmBody = new CANNON.Body({
                    mass: 3,
                    shape: upperArmShape
                });
                
                if (isPhysicsEnabled) {
                    world.add(upperArmBody);
                }
                
                ragdoll.parts.push({
                    mesh: upperArmMesh,
                    body: upperArmBody,
                    type: 'upperArm',
                    side: side
                });
                
                // Lower arm
                const lowerArmGeometry = new THREE.BoxGeometry(partSize * 0.7, partSize * 1.5, partSize * 0.7);
                const lowerArmMesh = new THREE.Mesh(lowerArmGeometry, ragdollMaterial);
                lowerArmMesh.castShadow = true;
                scene.add(lowerArmMesh);
                
                const lowerArmShape = new CANNON.Box(new CANNON.Vec3(partSize * 0.35, partSize * 0.75, partSize * 0.35));
                const lowerArmBody = new CANNON.Body({
                    mass: 2,
                    shape: lowerArmShape
                });
                
                if (isPhysicsEnabled) {
                    world.add(lowerArmBody);
                }
                
                ragdoll.parts.push({
                    mesh: lowerArmMesh,
                    body: lowerArmBody,
                    type: 'lowerArm',
                    side: side
                });
            }
            
            // Legs
            for (let i = 0; i < 2; i++) {
                const side = i === 0 ? -1 : 1;
                
                // Upper leg
                const upperLegGeometry = new THREE.BoxGeometry(partSize * 0.8, partSize * 1.5, partSize * 0.8);
                const upperLegMesh = new THREE.Mesh(upperLegGeometry, ragdollMaterial);
                upperLegMesh.castShadow = true;
                scene.add(upperLegMesh);
                
                const upperLegShape = new CANNON.Box(new CANNON.Vec3(partSize * 0.4, partSize * 0.75, partSize * 0.4));
                const upperLegBody = new CANNON.Body({
                    mass: 5,
                    shape: upperLegShape
                });
                
                if (isPhysicsEnabled) {
                    world.add(upperLegBody);
                }
                
                ragdoll.parts.push({
                    mesh: upperLegMesh,
                    body: upperLegBody,
                    type: 'upperLeg',
                    side: side
                });
                
                // Lower leg
                const lowerLegGeometry = new THREE.BoxGeometry(partSize * 0.7, partSize * 1.5, partSize * 0.7);
                const lowerLegMesh = new THREE.Mesh(lowerLegGeometry, ragdollMaterial);
                lowerLegMesh.castShadow = true;
                scene.add(lowerLegMesh);
                
                const lowerLegShape = new CANNON.Box(new CANNON.Vec3(partSize * 0.35, partSize * 0.75, partSize * 0.35));
                const lowerLegBody = new CANNON.Body({
                    mass: 4,
                    shape: lowerLegShape
                });
                
                if (isPhysicsEnabled) {
                    world.add(lowerLegBody);
                }
                
                ragdoll.parts.push({
                    mesh: lowerLegMesh,
                    body: lowerLegBody,
                    type: 'lowerLeg',
                    side: side
                });
            }
            
            // Position ragdoll parts
            const ragdollPosition = new THREE.Vector3(
                (Math.random() - 0.5) * 60,
                5,
                (Math.random() - 0.5) * 60
            );
            
            ragdoll.parts.forEach(part => {
                // Set initial positions
                const offset = new THREE.Vector3();
                
                switch(part.type) {
                    case 'head':
                        offset.y = partSize * 3;
                        break;
                    case 'torso':
                        offset.y = partSize * 1.5;
                        break;
                    case 'upperArm':
                        offset.x = part.side * partSize * 1.5;
                        offset.y = partSize * 2.5;
                        break;
                    case 'lowerArm':
                        offset.x = part.side * partSize * 2.5;
                        offset.y = partSize * 1.5;
                        break;
                    case 'upperLeg':
                        offset.x = part.side * partSize * 0.7;
                        offset.y = -partSize * 0.75;
                        break;
                    case 'lowerLeg':
                        offset.x = part.side * partSize * 0.7;
                        offset.y = -partSize * 2;
                        break;
                }
                
                part.mesh.position.copy(ragdollPosition).add(offset);
                part.body.position.copy(part.mesh.position);
            });
            
            // Create constraints between parts
            if (isPhysicsEnabled) {
                // Head to torso
                const headToTorso = new CANNON.PointToPointConstraint(
                    ragdoll.parts.find(p => p.type === 'head').body,
                    new CANNON.Vec3(0, -partSize * 1.5, 0),
                    ragdoll.parts.find(p => p.type === 'torso').body,
                    new CANNON.Vec3(0, partSize * 1.5, 0)
                );
                world.add(headToTorso);
                ragdoll.constraints.push(headToTorso);
                
                // Arms to torso
                ragdoll.parts.filter(p => p.type === 'upperArm').forEach(arm => {
                    const armToTorso = new CANNON.PointToPointConstraint(
                        arm.body,
                        new CANNON.Vec3(0, partSize * 0.75, 0),
                        ragdoll.parts.find(p => p.type === 'torso').body,
                        new CANNON.Vec3(arm.side * partSize, partSize * 0.75, 0)
                    );
                    world.add(armToTorso);
                    ragdoll.constraints.push(armToTorso);
                });
                
                // Upper arms to lower arms
                ragdoll.parts.filter(p => p.type === 'upperArm').forEach(upperArm => {
                    const lowerArm = ragdoll.parts.find(p => p.type === 'lowerArm' && p.side === upperArm.side);
                    const upperToLowerArm = new CANNON.PointToPointConstraint(
                        upperArm.body,
                        new CANNON.Vec3(0, -partSize * 0.75, 0),
                        lowerArm.body,
                        new CANNON.Vec3(0, partSize * 0.75, 0)
                    );
                    world.add(upperToLowerArm);
                    ragdoll.constraints.push(upperToLowerArm);
                });
                
                // Legs to torso
                ragdoll.parts.filter(p => p.type === 'upperLeg').forEach(leg => {
                    const legToTorso = new CANNON.PointToPointConstraint(
                        leg.body,
                        new CANNON.Vec3(0, partSize * 0.75, 0),
                        ragdoll.parts.find(p => p.type === 'torso').body,
                        new CANNON.Vec3(leg.side * partSize * 0.7, -partSize * 0.75, 0)
                    );
                    world.add(legToTorso);
                    ragdoll.constraints.push(legToTorso);
                });
                
                // Upper legs to lower legs
                ragdoll.parts.filter(p => p.type === 'upperLeg').forEach(upperLeg => {
                    const lowerLeg = ragdoll.parts.find(p => p.type === 'lowerLeg' && p.side === upperLeg.side);
                    const upperToLowerLeg = new CANNON.PointToPointConstraint(
                        upperLeg.body,
                        new CANNON.Vec3(0, -partSize * 0.75, 0),
                        lowerLeg.body,
                        new CANNON.Vec3(0, partSize * 0.75, 0)
                    );
                    world.add(upperToLowerLeg);
                    ragdoll.constraints.push(upperToLowerLeg);
                });
            }
            
            // Add ragdoll to list
            ragdolls.push(ragdoll);
            updateStats();
        }
        
        function updateAIHumans() {
            aiHumans.forEach(human => {
                // Update needs
                human.hunger -= 0.01;
                human.thirst -= 0.02;
                human.energy -= 0.005;
                
                // Clamp needs between 0 and 100
                human.hunger = Math.max(0, Math.min(100, human.hunger));
                human.thirst = Math.max(0, Math.min(100, human.thirst));
                human.energy = Math.max(0, Math.min(100, human.energy));
                
                // Check if human is in water
                const gridX = Math.floor(human.mesh.position.x / waterGridSize);
                const gridZ = Math.floor(human.mesh.position.z / waterGridSize);
                const waterKey = `${gridX},${gridZ}`;
                const waterDepth = waterGrid[waterKey] || 0;
                
                // Slow down in water
                if (waterDepth > 0.3) {
                    human.speed = aiSpeed * 0.5 * (1 - waterDepth * 0.5);
                } else {
                    human.speed = aiSpeed + Math.random() * 0.05;
                }
                
                // Update think timer
                human.thinkTimer++;
                
                // Make decisions periodically
                if (human.thinkTimer > 50) {
                    human.thinkTimer = 0;
                    makeAIDecision(human);
                }
                
                // Update shoot timer
                if (human.shootTimer > 0) {
                    human.shootTimer--;
                }
                
                // Update interaction timer
                if (human.interactionTimer > 0) {
                    human.interactionTimer--;
                    if (human.interactionTimer === 0) {
                        // End interaction
                        human.interactionElement.style.display = 'none';
                        human.state = 'wandering';
                    }
                }
                
                // Update speech timer
                if (human.speechTimer > 0) {
                    human.speechTimer--;
                    if (human.speechTimer === 0) {
                        // Hide speech bubble
                        human.speechBubbleElement.style.display = 'none';
                    }
                }
                
                // Update emotion timer
                if (human.emotionTimer > 0) {
                    human.emotionTimer--;
                    if (human.emotionTimer === 0) {
                        // Hide emotion indicator
                        human.emotionElement.style.display = 'none';
                    }
                }
                
                // Update animation timer
                human.animationTimer++;
                
                // Execute current behavior
                switch(human.state) {
                    case 'wandering':
                        wanderBehavior(human);
                        break;
                    case 'seeking':
                        seekBehavior(human);
                        break;
                    case 'attacking':
                        attackBehavior(human);
                        break;
                    case 'fleeing':
                        fleeBehavior(human);
                        break;
                    case 'interacting':
                        interactBehavior(human);
                        break;
                    case 'entering':
                        enteringBehavior(human);
                        break;
                    case 'inside':
                        insideBehavior(human);
                        break;
                    case 'exiting':
                        exitingBehavior(human);
                        break;
                }
                
                // Update animations
                updateAnimations(human);
                
                // Update physics body position if physics is enabled
                if (isPhysicsEnabled && !human.insideBuilding) {
                    human.body.position.copy(human.mesh.position);
                    human.body.position.y += 0.85;
                }
                
                // Update held gun position and rotation
                if (human.heldGun) {
                    updateHeldGun(human);
                }
                
                // Update health bar position
                updateHealthBar(human);
                
                // Check if human is stuck
                const currentPosition = human.mesh.position.clone();
                const distanceMoved = currentPosition.distanceTo(human.lastPosition);
                
                if (distanceMoved < 0.01) {
                    human.stuckTimer++;
                    
                    // If stuck for too long, find a new target position
                    if (human.stuckTimer > 30) {
                        human.targetPosition.set(
                            (Math.random() - 0.5) * 60,
                            0,
                            (Math.random() - 0.5) * 60
                        );
                        human.stuckTimer = 0;
                        
                        // Show confused emotion
                        showEmotion(human, emotions[7], 2000); // Confused
                    }
                } else {
                    human.stuckTimer = 0;
                }
                
                human.lastPosition.copy(currentPosition);
            });
            
            // Clean up dead humans
            aiHumans = aiHumans.filter(human => {
                if (human.health <= 0) {
                    // Remove human from scene
                    scene.remove(human.mesh);
                    
                    // Remove health bar
                    if (human.healthBarElement) {
                        healthBarsContainer.removeChild(human.healthBarElement);
                    }
                    
                    // Remove interaction indicators
                    if (human.interactionElement) {
                        healthBarsContainer.removeChild(human.interactionElement);
                    }
                    
                    // Remove speech bubble
                    if (human.speechBubbleElement) {
                        healthBarsContainer.removeChild(human.speechBubbleElement);
                    }
                    
                    // Remove emotion indicator
                    if (human.emotionElement) {
                        healthBarsContainer.removeChild(human.emotionElement);
                    }
                    
                    // Drop gun if holding one
                    if (human.heldGun) {
                        human.heldGun.isHeld = false;
                        human.heldGun.holder = null;
                        
                        // Add physics back to gun
                        if (isPhysicsEnabled) {
                            world.add(human.heldGun.body);
                            human.heldGun.body.position.copy(human.mesh.position);
                            human.heldGun.body.position.y += 1;
                        }
                    }
                    
                    // Remove from physics world
                    if (isPhysicsEnabled) {
                        world.remove(human.body);
                    }
                    
                    // Remove from building if inside
                    if (human.insideBuilding) {
                        if (human.insideBuilding.type === 'house' && human.insideBuilding.data.occupants) {
                            const index = human.insideBuilding.data.occupants.indexOf(human);
                            if (index !== -1) {
                                human.insideBuilding.data.occupants.splice(index, 1);
                            }
                        } else if (human.insideBuilding.type === 'farm' && human.insideBuilding.data.workers) {
                            const index = human.insideBuilding.data.workers.indexOf(human);
                            if (index !== -1) {
                                human.insideBuilding.data.workers.splice(index, 1);
                            }
                        } else if (human.insideBuilding.type === 'luxury' && human.insideBuilding.data.occupants) {
                            const index = human.insideBuilding.data.occupants.indexOf(human);
                            if (index !== -1) {
                                human.insideBuilding.data.occupants.splice(index, 1);
                            }
                        }
                    }
                    
                    return false; // Remove from array
                }
                return true; // Keep in array
            });
            
            updateStats();
            
            // Update camera targets if auto camera is enabled
            if (autoCameraEnabled) {
                updateCameraTargets();
            }
        }
        
        function makeAIDecision(human) {
            // If inside a building, decide when to exit
            if (human.insideBuilding) {
                human.buildingExitTimer++;
                
                // Random chance to exit building
                if (human.buildingExitTimer > 100 && Math.random() < 0.1) {
                    human.state = 'exiting';
                    human.buildingExitTimer = 0;
                    return;
                }
            }
            
            // Check needs
            if (human.hunger > 80) {
                // Human is hungry, look for food
                if (currentBiome === 'town' && window.townFarms) {
                    // Find nearest farm
                    let nearestFarm = null;
                    let nearestDistance = Infinity;
                    
                    window.townFarms.forEach(farm => {
                        const distance = human.mesh.position.distanceTo(farm.position);
                        if (distance < nearestDistance) {
                            nearestDistance = distance;
                            nearestFarm = farm;
                        }
                    });
                    
                    if (nearestFarm && nearestDistance < 20) {
                        human.state = 'seeking';
                        human.targetBuilding = { type: 'farm', data: nearestFarm };
                        return;
                    }
                }
            }
            
            if (human.thirst > 80) {
                // Human is thirsty, look for water
                if (currentBiome === 'town' && window.townPools) {
                    // Find nearest pool
                    let nearestPool = null;
                    let nearestDistance = Infinity;
                    
                    window.townPools.forEach(pool => {
                        const distance = human.mesh.position.distanceTo(pool.position);
                        if (distance < nearestDistance) {
                            nearestDistance = distance;
                            nearestPool = pool;
                        }
                    });
                    
                    if (nearestPool && nearestDistance < 20) {
                        human.state = 'seeking';
                        human.targetBuilding = { type: 'pool', data: nearestPool };
                        return;
                    }
                }
            }
            
            if (human.energy < 20) {
                // Human is tired, look for a place to rest
                if (currentBiome === 'town' && window.townHouses) {
                    // Find nearest house
                    let nearestHouse = null;
                    let nearestDistance = Infinity;
                    
                    window.townHouses.forEach(house => {
                        const distance = human.mesh.position.distanceTo(house.position);
                        if (distance < nearestDistance) {
                            nearestDistance = distance;
                            nearestHouse = house;
                        }
                    });
                    
                    if (nearestHouse && nearestDistance < 20) {
                        human.state = 'seeking';
                        human.targetBuilding = { type: 'house', data: nearestHouse };
                        return;
                    }
                } else if (currentBiome === 'luxury' && window.luxuryHouses) {
                    // Find nearest luxury house
                    let nearestHouse = null;
                    let nearestDistance = Infinity;
                    
                    window.luxuryHouses.forEach(house => {
                        const distance = human.mesh.position.distanceTo(house.position);
                        if (distance < nearestDistance) {
                            nearestDistance = distance;
                            nearestHouse = house;
                        }
                    });
                    
                    if (nearestHouse && nearestDistance < 20) {
                        human.state = 'seeking';
                        human.targetBuilding = { type: 'luxury', data: nearestHouse };
                        return;
                    }
                }
            }
            
            // If health is low, prioritize fleeing
            if (human.health < 30) {
                human.state = 'fleeing';
                return;
            }
            
            // If holding a gun and aggression is enabled, look for targets
            if (human.heldGun && aiAggression && human.aggression > 0.5) {
                // Find nearest enemy
                let nearestEnemy = null;
                let nearestDistance = Infinity;
                
                aiHumans.forEach(otherHuman => {
                    if (otherHuman !== human && otherHuman.heldGun && otherHuman.health > 0 && !otherHuman.insideBuilding) {
                        const distance = human.mesh.position.distanceTo(otherHuman.mesh.position);
                        if (distance < nearestDistance && distance < 20) { // Within range
                            // Check relationship
                            const relationship = human.relationships[otherHuman.mesh.uuid] || 0;
                            if (relationship < 0.3) { // Negative relationship
                                nearestDistance = distance;
                                nearestEnemy = otherHuman;
                            }
                        }
                    }
                });
                
                if (nearestEnemy) {
                    human.state = 'attacking';
                    human.targetHuman = nearestEnemy;
                    return;
                }
            }
            
            // If interactions are enabled, look for humans to interact with
            if (aiInteractions && human.sociability > 0.5) {
                // Find nearest friendly human
                let nearestFriend = null;
                let nearestDistance = Infinity;
                
                aiHumans.forEach(otherHuman => {
                    if (otherHuman !== human && otherHuman.health > 0 && !otherHuman.insideBuilding) {
                        const distance = human.mesh.position.distanceTo(otherHuman.mesh.position);
                        if (distance < nearestDistance && distance < 5) { // Within interaction range
                            // Check relationship
                            const relationship = human.relationships[otherHuman.mesh.uuid] || 0;
                            if (relationship > 0.5) { // Positive relationship
                                nearestDistance = distance;
                                nearestFriend = otherHuman;
                            }
                        }
                    }
                });
                
                if (nearestFriend) {
                    human.state = 'interacting';
                    human.targetHuman = nearestFriend;
                    return;
                }
            }
            
            // If no gun, look for one
            if (!human.heldGun) {
                // Find nearest gun
                let nearestGun = null;
                let nearestDistance = Infinity;
                
                guns.forEach(gun => {
                    if (!gun.isHeld) {
                        const distance = human.mesh.position.distanceTo(gun.mesh.position);
                        if (distance < nearestDistance) {
                            nearestDistance = distance;
                            nearestGun = gun;
                        }
                    }
                });
                
                if (nearestGun && nearestDistance < 15) { // If gun is close enough
                    human.state = 'seeking';
                    human.targetGun = nearestGun;
                    return;
                }
            }
            
            // In town biome, look for buildings to enter
            if (currentBiome === 'town' && !human.insideBuilding) {
                // Find nearest building
                let nearestBuilding = null;
                let nearestDistance = Infinity;
                
                // Check houses
                if (window.townHouses) {
                    window.townHouses.forEach(house => {
                        const distance = human.mesh.position.distanceTo(house.position);
                        if (distance < nearestDistance && distance < 10) {
                            nearestDistance = distance;
                            nearestBuilding = { type: 'house', data: house };
                        }
                    });
                }
                
                // Check pools
                if (window.townPools) {
                    window.townPools.forEach(pool => {
                        const distance = human.mesh.position.distanceTo(pool.position);
                        if (distance < nearestDistance && distance < 10) {
                            nearestDistance = distance;
                            nearestBuilding = { type: 'pool', data: pool };
                        }
                    });
                }
                
                // Check farms
                if (window.townFarms) {
                    window.townFarms.forEach(farm => {
                        const distance = human.mesh.position.distanceTo(farm.position);
                        if (distance < nearestDistance && distance < 15) {
                            nearestDistance = distance;
                            nearestBuilding = { type: 'farm', data: farm };
                        }
                    });
                }
                
                if (nearestBuilding) {
                    // Random chance to enter building
                    if (Math.random() < 0.3) {
                        human.state = 'entering';
                        human.targetBuilding = nearestBuilding;
                        return;
                    }
                }
            }
            
            // In luxury biome, look for buildings to enter
            if (currentBiome === 'luxury' && !human.insideBuilding) {
                // Find nearest building
                let nearestBuilding = null;
                let nearestDistance = Infinity;
                
                // Check luxury houses
                if (window.luxuryHouses) {
                    window.luxuryHouses.forEach(house => {
                        const distance = human.mesh.position.distanceTo(house.position);
                        if (distance < nearestDistance && distance < 15) {
                            nearestDistance = distance;
                            nearestBuilding = { type: 'luxury', data: house };
                        }
                    });
                }
                
                if (nearestBuilding) {
                    // Random chance to enter building
                    if (Math.random() < 0.4) {
                        human.state = 'entering';
                        human.targetBuilding = nearestBuilding;
                        return;
                    }
                }
            }
            
            // Default to wandering
            human.state = 'wandering';
            human.targetPosition.set(
                (Math.random() - 0.5) * 60,
                0,
                (Math.random() - 0.5) * 60
            );
        }
        
        function wanderBehavior(human) {
            // Move towards target
            const direction = new THREE.Vector3();
            direction.subVectors(human.targetPosition, human.mesh.position);
            direction.y = 0; // Keep on ground plane
            
            if (direction.length() > 0.5) {
                direction.normalize();
                
                // Check for collisions before moving
                const newPosition = human.mesh.position.clone().add(direction.multiplyScalar(human.speed));
                
                if (!checkCollision(human, newPosition)) {
                    human.mesh.position.copy(newPosition);
                    
                    // Rotate to face movement direction
                    human.mesh.lookAt(human.targetPosition);
                    
                    // Set animation state
                    human.animationState = 'walking';
                } else {
                    // If collision detected, find a new target
                    human.targetPosition.set(
                        (Math.random() - 0.5) * 60,
                        0,
                        (Math.random() - 0.5) * 60
                    );
                    
                    // Show confused emotion
                    showEmotion(human, emotions[7], 2000); // Confused
                }
            } else {
                // Reached target, get new one
                human.targetPosition.set(
                    (Math.random() - 0.5) * 60,
                    0,
                    (Math.random() - 0.5) * 60
                );
                
                // Set animation state
                human.animationState = 'idle';
            }
        }
        
        function seekBehavior(human) {
            let targetPosition;
            
            if (human.targetGun) {
                if (human.targetGun.isHeld) {
                    // Gun is no longer available, go back to wandering
                    human.state = 'wandering';
                    human.targetGun = null;
                    return;
                }
                targetPosition = human.targetGun.mesh.position;
            } else if (human.targetBuilding) {
                targetPosition = human.targetBuilding.data.position;
            } else {
                // No target, go back to wandering
                human.state = 'wandering';
                return;
            }
            
            // Move towards target
            const direction = new THREE.Vector3();
            direction.subVectors(targetPosition, human.mesh.position);
            direction.y = 0;
            
            if (direction.length() > 1) {
                direction.normalize();
                
                // Check for collisions before moving
                const newPosition = human.mesh.position.clone().add(direction.multiplyScalar(human.speed));
                
                if (!checkCollision(human, newPosition)) {
                    human.mesh.position.copy(newPosition);
                    
                    // Rotate to face target
                    human.mesh.lookAt(targetPosition);
                    
                    // Set animation state
                    human.animationState = 'walking';
                } else {
                    // If collision detected, try to find a path around
                    const perpendicular = new THREE.Vector3(-direction.z, 0, direction.x);
                    const sidePosition = human.mesh.position.clone().add(perpendicular.multiplyScalar(human.speed * 2));
                    
                    if (!checkCollision(human, sidePosition)) {
                        human.mesh.position.copy(sidePosition);
                    } else {
                        // Try the other direction
                        const otherSidePosition = human.mesh.position.clone().add(perpendicular.multiplyScalar(-human.speed * 2));
                        
                        if (!checkCollision(human, otherSidePosition)) {
                            human.mesh.position.copy(otherSidePosition);
                        } else {
                            // If both sides are blocked, go back to wandering
                            human.state = 'wandering';
                            human.targetGun = null;
                            human.targetBuilding = null;
                            
                            // Show frustrated emotion
                            showEmotion(human, emotions[2], 2000); // Angry
                        }
                    }
                }
            } else {
                // Reached target
                if (human.targetGun) {
                    // Reached gun, pick it up
                    pickupGun(human, human.targetGun);
                    human.state = 'wandering';
                    human.targetGun = null;
                    
                    // Set animation state
                    human.animationState = 'idle';
                } else if (human.targetBuilding) {
                    // Reached building, enter it
                    human.state = 'entering';
                    
                    // Set animation state
                    human.animationState = 'idle';
                }
            }
        }
        
        function attackBehavior(human) {
            if (!human.targetHuman || human.targetHuman.health <= 0 || human.targetHuman.insideBuilding) {
                // Target is dead or inside building, find a new one or go back to wandering
                human.state = 'wandering';
                human.targetHuman = null;
                return;
            }
            
            // Calculate distance to target
            const distance = human.mesh.position.distanceTo(human.targetHuman.mesh.position);
            
            // If too far, get closer
            if (distance > 15) {
                const direction = new THREE.Vector3();
                direction.subVectors(human.targetHuman.mesh.position, human.mesh.position);
                direction.y = 0;
                direction.normalize();
                
                // Check for collisions before moving
                const newPosition = human.mesh.position.clone().add(direction.multiplyScalar(human.speed));
                
                if (!checkCollision(human, newPosition)) {
                    human.mesh.position.copy(newPosition);
                    
                    // Set animation state
                    human.animationState = 'running';
                } else {
                    // If collision detected, try to find a path
                    const perpendicular = new THREE.Vector3(-direction.z, 0, direction.x);
                    const sidePosition = human.mesh.position.clone().add(perpendicular.multiplyScalar(human.speed * 2));
                    
                    if (!checkCollision(human, sidePosition)) {
                        human.mesh.position.copy(sidePosition);
                    } else {
                        // Try the other direction
                        const otherSidePosition = human.mesh.position.clone().add(perpendicular.multiplyScalar(-human.speed * 2));
                        
                        if (!checkCollision(human, otherSidePosition)) {
                            human.mesh.position.copy(otherSidePosition);
                        } else {
                            // If both sides are blocked, give up
                            human.state = 'wandering';
                            human.targetHuman = null;
                            
                            // Show frustrated emotion
                            showEmotion(human, emotions[2], 2000); // Angry
                        }
                    }
                }
            } else {
                // Set animation state
                human.animationState = 'idle';
            }
            
            // Rotate to face target
            human.mesh.lookAt(human.targetHuman.mesh.position);
            
            // Shoot if gun is ready and target is in range
            if (human.heldGun && human.shootTimer === 0 && distance < 20) {
                shootGun(human, human.targetHuman);
                human.shootTimer = 30; // Cooldown between shots
                
                // Worsen relationship with target
                human.relationships[human.targetHuman.mesh.uuid] = 
                    (human.relationships[human.targetHuman.mesh.uuid] || 0) - 0.2;
                
                // Show angry emotion
                showEmotion(human, emotions[2], 2000); // Angry
                
                // Show aggressive speech
                if (aiSpeech) {
                    const phrases = [
                        "Take this! 🔫",
                        "You're going down! 💥",
                        "Get out of my way! 🚫",
                        "I'll show you! 👊",
                        "This is your end! ⚰️"
                    ];
                    const phrase = phrases[Math.floor(Math.random() * phrases.length)];
                    showSpeech(human, phrase, 2000);
                }
            }
        }
        
        function fleeBehavior(human) {
            // Find direction away from nearest threat
            let threatPosition = new THREE.Vector3();
            let foundThreat = false;
            
            // Look for armed humans
            aiHumans.forEach(otherHuman => {
                if (otherHuman !== human && otherHuman.heldGun && otherHuman.health > 0 && !otherHuman.insideBuilding) {
                    const distance = human.mesh.position.distanceTo(otherHuman.mesh.position);
                    if (distance < 15) { // If threat is close
                        threatPosition.copy(otherHuman.mesh.position);
                        foundThreat = true;
                    }
                }
            });
            
            if (foundThreat) {
                // Calculate flee direction (away from threat)
                const fleeDirection = new THREE.Vector3();
                fleeDirection.subVectors(human.mesh.position, threatPosition);
                fleeDirection.y = 0;
                fleeDirection.normalize();
                
                // Check for collisions before moving
                const newPosition = human.mesh.position.clone().add(fleeDirection.multiplyScalar(human.speed * 1.5)); // Flee faster
                
                if (!checkCollision(human, newPosition)) {
                    human.mesh.position.copy(newPosition);
                    
                    // Rotate to face away from threat
                    human.mesh.lookAt(human.mesh.position.clone().add(fleeDirection));
                    
                    // Set animation state
                    human.animationState = 'running';
                } else {
                    // If collision detected, try to find a path
                    const perpendicular = new THREE.Vector3(-fleeDirection.z, 0, fleeDirection.x);
                    const sidePosition = human.mesh.position.clone().add(perpendicular.multiplyScalar(human.speed * 2));
                    
                    if (!checkCollision(human, sidePosition)) {
                        human.mesh.position.copy(sidePosition);
                    } else {
                        // Try the other direction
                        const otherSidePosition = human.mesh.position.clone().add(perpendicular.multiplyScalar(-human.speed * 2));
                        
                        if (!checkCollision(human, otherSidePosition)) {
                            human.mesh.position.copy(otherSidePosition);
                        } else {
                            // Try to find a safe direction
                            for (let i = 0; i < 8; i++) {
                                const angle = (i / 8) * Math.PI * 2;
                                const testDirection = new THREE.Vector3(Math.cos(angle), 0, Math.sin(angle));
                                const testPosition = human.mesh.position.clone().add(testDirection.multiplyScalar(human.speed * 2));
                                
                                if (!checkCollision(human, testPosition)) {
                                    human.mesh.position.copy(testPosition);
                                    break;
                                }
                            }
                        }
                    }
                }
                
                // Show scared emotion
                if (human.emotionTimer === 0) {
                    showEmotion(human, emotions[3], 2000); // Surprised/fear
                }
                
                // Show fear speech
                if (aiSpeech && human.speechTimer === 0) {
                    const phrases = [
                        "Help! 😱",
                        "Run away! 🏃‍♂️",
                        "I'm scared! 😨",
                        "Medic! 🚑",
                        "Don't hurt me! 🙏"
                    ];
                    const phrase = phrases[Math.floor(Math.random() * phrases.length)];
                    showSpeech(human, phrase, 2000);
                }
            } else {
                // No immediate threat, go back to wandering
                human.state = 'wandering';
                
                // Set animation state
                human.animationState = 'idle';
            }
        }
        
        function interactBehavior(human) {
            if (!human.targetHuman || human.targetHuman.health <= 0 || human.targetHuman.insideBuilding) {
                // Target is dead or inside building, go back to wandering
                human.state = 'wandering';
                human.targetHuman = null;
                human.interactionElement.style.display = 'none';
                return;
            }
            
            // Calculate distance to target
            const distance = human.mesh.position.distanceTo(human.targetHuman.mesh.position);
            
            // If too far, get closer
            if (distance > 2) {
                const direction = new THREE.Vector3();
                direction.subVectors(human.targetHuman.mesh.position, human.mesh.position);
                direction.y = 0;
                direction.normalize();
                
                // Check for collisions before moving
                const newPosition = human.mesh.position.clone().add(direction.multiplyScalar(human.speed));
                
                if (!checkCollision(human, newPosition)) {
                    human.mesh.position.copy(newPosition);
                    
                    // Set animation state
                    human.animationState = 'walking';
                } else {
                    // If collision detected, try to find a path
                    const perpendicular = new THREE.Vector3(-direction.z, 0, direction.x);
                    const sidePosition = human.mesh.position.clone().add(perpendicular.multiplyScalar(human.speed * 2));
                    
                    if (!checkCollision(human, sidePosition)) {
                        human.mesh.position.copy(sidePosition);
                    } else {
                        // Try the other direction
                        const otherSidePosition = human.mesh.position.clone().add(perpendicular.multiplyScalar(-human.speed * 2));
                        
                        if (!checkCollision(human, otherSidePosition)) {
                            human.mesh.position.copy(otherSidePosition);
                        } else {
                            // If both sides are blocked, give up
                            human.state = 'wandering';
                            human.targetHuman = null;
                            human.interactionElement.style.display = 'none';
                            
                            // Show frustrated emotion
                            showEmotion(human, emotions[7], 2000); // Confused
                        }
                    }
                }
            } else {
                // Close enough to interact
                // Rotate to face target
                human.mesh.lookAt(human.targetHuman.mesh.position);
                
                // Show interaction indicator
                human.interactionElement.style.display = 'block';
                
                // Set animation state
                human.animationState = 'interacting';
                
                // Set interaction timer
                if (human.interactionTimer === 0) {
                    human.interactionTimer = 100; // Interaction duration
                    
                    // Improve relationship
                    human.relationships[human.targetHuman.mesh.uuid] = 
                        (human.relationships[human.targetHuman.mesh.uuid] || 0) + 0.1;
                    
                    // Show happy emotion
                    showEmotion(human, emotions[0], 2000); // Happy
                    
                    // Show friendly speech
                    if (aiSpeech) {
                        const phrases = speechPhrases.happy;
                        const phrase = phrases[Math.floor(Math.random() * phrases.length)];
                        showSpeech(human, phrase, 2000);
                    }
                    
                    // Make the other human also interact
                    human.targetHuman.state = 'interacting';
                    human.targetHuman.targetHuman = human;
                    human.targetHuman.interactionTimer = 100;
                    human.targetHuman.interactionElement.style.display = 'block';
                    human.targetHuman.relationships[human.mesh.uuid] = 
                        (human.targetHuman.relationships[human.mesh.uuid] || 0) + 0.1;
                    
                    // Show happy emotion on other human
                    showEmotion(human.targetHuman, emotions[0], 2000); // Happy
                    
                    // Show friendly speech from other human
                    if (aiSpeech) {
                        const phrases = speechPhrases.happy;
                        const phrase = phrases[Math.floor(Math.random() * phrases.length)];
                        showSpeech(human.targetHuman, phrase, 2000);
                    }
                }
            }
        }
        
        function enteringBehavior(human) {
            if (!human.targetBuilding) {
                // No target building, go back to wandering
                human.state = 'wandering';
                return;
            }
            
            // Move towards building entrance
            let targetPosition;
            
            if (human.targetBuilding.type === 'house' && human.targetBuilding.data.doorPosition) {
                // Move to door position
                targetPosition = human.targetBuilding.data.doorPosition;
            } else if (human.targetBuilding.type === 'luxury' && human.targetBuilding.data.doors) {
                // Move to front door position
                targetPosition = human.targetBuilding.data.doors[0];
            } else {
                // Move to building center
                targetPosition = human.targetBuilding.data.position;
            }
            
            const direction = new THREE.Vector3();
            direction.subVectors(targetPosition, human.mesh.position);
            direction.y = 0;
            
            if (direction.length() > 0.5) {
                direction.normalize();
                
                // Check for collisions before moving
                const newPosition = human.mesh.position.clone().add(direction.multiplyScalar(human.speed));
                
                if (!checkCollision(human, newPosition)) {
                    human.mesh.position.copy(newPosition);
                    
                    // Rotate to face building
                    human.mesh.lookAt(targetPosition);
                    
                    // Set animation state
                    human.animationState = 'walking';
                } else {
                    // If collision detected, try to find a path
                    const perpendicular = new THREE.Vector3(-direction.z, 0, direction.x);
                    const sidePosition = human.mesh.position.clone().add(perpendicular.multiplyScalar(human.speed * 2));
                    
                    if (!checkCollision(human, sidePosition)) {
                        human.mesh.position.copy(sidePosition);
                    } else {
                        // Try the other direction
                        const otherSidePosition = human.mesh.position.clone().add(perpendicular.multiplyScalar(-human.speed * 2));
                        
                        if (!checkCollision(human, otherSidePosition)) {
                            human.mesh.position.copy(otherSidePosition);
                        } else {
                            // If both sides are blocked, give up
                            human.state = 'wandering';
                            human.targetBuilding = null;
                            
                            // Show frustrated emotion
                            showEmotion(human, emotions[7], 2000); // Confused
                        }
                    }
                }
            } else {
                // Reached building, enter it
                human.state = 'inside';
                human.insideBuilding = human.targetBuilding;
                human.buildingExitTimer = 0;
                
                // Hide human mesh
                human.mesh.visible = false;
                
                // Add human to building occupants/workers
                if (human.targetBuilding.type === 'house' && human.targetBuilding.data.occupants) {
                    human.targetBuilding.data.occupants.push(human);
                } else if (human.targetBuilding.type === 'farm' && human.targetBuilding.data.workers) {
                    human.targetBuilding.data.workers.push(human);
                } else if (human.targetBuilding.type === 'pool' && human.targetBuilding.data.swimmers) {
                    if (!human.targetBuilding.data.swimmers) {
                        human.targetBuilding.data.swimmers = [];
                    }
                    human.targetBuilding.data.swimmers.push(human);
                } else if (human.targetBuilding.type === 'luxury' && human.targetBuilding.data.occupants) {
                    human.targetBuilding.data.occupants.push(human);
                }
                
                // Show entering speech
                if (aiSpeech) {
                    let phrase = "Entering... 🚪";
                    if (human.targetBuilding.type === 'house') {
                        phrase = "Going home! 🏠";
                    } else if (human.targetBuilding.type === 'pool') {
                        phrase = "Time for a swim! 🏊‍♂️";
                    } else if (human.targetBuilding.type === 'farm') {
                        phrase = "Time to work! 🚜";
                    } else if (human.targetBuilding.type === 'luxury') {
                        phrase = "Entering luxury house! 🏰";
                    }
                    showSpeech(human, phrase, 2000);
                }
            }
        }
        
        function insideBehavior(human) {
            // While inside, human is invisible but still exists
            // Just increment the exit timer
            human.buildingExitTimer++;
            
            // Satisfy needs based on building type
            if (human.insideBuilding.type === 'house') {
                // Rest at home
                human.energy += 0.1;
                human.hunger -= 0.05;
                human.thirst -= 0.05;
            } else if (human.insideBuilding.type === 'pool') {
                // Swimming in pool
                human.thirst += 0.05; // Actually increases thirst
                human.energy += 0.05;
            } else if (human.insideBuilding.type === 'farm') {
                // Working on farm
                human.energy -= 0.05;
                human.hunger += 0.1; // Working makes you hungry
                human.thirst -= 0.05;
            } else if (human.insideBuilding.type === 'luxury') {
                // In luxury house
                human.energy += 0.15; // More restful
                human.hunger -= 0.03;
                human.thirst -= 0.03;
            }
            
            // Random chance to show speech from inside
            if (aiSpeech && Math.random() < 0.01) {
                let phrase = "Inside... 🏠";
                
                if (human.insideBuilding.type === 'house') {
                    const phrases = [
                        "Cozy at home! 🏠",
                        "Watching TV! 📺",
                        "Making food! 🍕",
                        "Taking a nap! 😴",
                        "Reading a book! 📚",
                        "Relaxing on the couch! 🛋️"
                    ];
                    phrase = phrases[Math.floor(Math.random() * phrases.length)];
                } else if (human.insideBuilding.type === 'pool') {
                    const phrases = [
                        "Swimming is fun! 🏊‍♂️",
                        "The water is nice! 💧",
                        "Doing laps! 🏊‍♀️",
                        "Relaxing in the pool! ☀️",
                        "Splashing around! 💦",
                        "Floating on my back! 🛁"
                    ];
                    phrase = phrases[Math.floor(Math.random() * phrases.length)];
                } else if (human.insideBuilding.type === 'farm') {
                    const phrases = [
                        "Working on the farm! 🚜",
                        "Planting crops! 🌱",
                        "Harvesting! 🌾",
                        "Feeding animals! 🐄",
                        "Tilling the soil! 🔨",
                        "Checking the fences! 🚧"
                    ];
                    phrase = phrases[Math.floor(Math.random() * phrases.length)];
                } else if (human.insideBuilding.type === 'luxury') {
                    const phrases = [
                        "This luxury house is amazing! 🏰",
                        "Relaxing in the pool! 🏊‍♂️",
                        "Watching the big screen TV! 📺",
                        "Cooking in the gourmet kitchen! 🍳",
                        "Sleeping in the master bedroom! 🛏️",
                        "Taking a shower in the fancy bathroom! 🚿"
                    ];
                    phrase = phrases[Math.floor(Math.random() * phrases.length)];
                }
                
                // Temporarily show human at building entrance for speech
                human.mesh.visible = true;
                human.mesh.position.copy(human.insideBuilding.data.position);
                showSpeech(human, phrase, 2000);
                
                // Hide human again after speech
                setTimeout(() => {
                    if (human.state === 'inside') {
                        human.mesh.visible = false;
                    }
                }, 2000);
            }
        }
        
        function exitingBehavior(human) {
            if (!human.insideBuilding) {
                // Not inside a building, go back to wandering
                human.state = 'wandering';
                human.mesh.visible = true;
                return;
            }
            
            // Move away from building
            let targetPosition;
            
            if (human.insideBuilding.type === 'house' && human.insideBuilding.data.doorPosition) {
                // Start at door position
                targetPosition = human.insideBuilding.data.doorPosition.clone();
                
                // Add offset to move away from door
                const direction = new THREE.Vector3();
                direction.subVectors(human.mesh.position, human.insideBuilding.data.position);
                direction.y = 0;
                direction.normalize();
                targetPosition.add(direction.multiplyScalar(3));
            } else if (human.insideBuilding.type === 'luxury' && human.insideBuilding.data.doors) {
                // Start at front door position
                targetPosition = human.insideBuilding.data.doors[0].clone();
                
                // Add offset to move away from door
                const direction = new THREE.Vector3();
                direction.subVectors(human.mesh.position, human.insideBuilding.data.position);
                direction.y = 0;
                direction.normalize();
                targetPosition.add(direction.multiplyScalar(3));
            } else {
                // Move away from building center
                const direction = new THREE.Vector3();
                direction.subVectors(human.mesh.position, human.insideBuilding.data.position);
                direction.y = 0;
                direction.normalize();
                targetPosition = human.mesh.position.clone().add(direction.multiplyScalar(3));
            }
            
            const direction = new THREE.Vector3();
            direction.subVectors(targetPosition, human.mesh.position);
            direction.y = 0;
            
            if (direction.length() > 0.5) {
                direction.normalize();
                
                // Make sure human is visible
                human.mesh.visible = true;
                
                // Check for collisions before moving
                const newPosition = human.mesh.position.clone().add(direction.multiplyScalar(human.speed));
                
                if (!checkCollision(human, newPosition)) {
                    human.mesh.position.copy(newPosition);
                    
                    // Rotate to face away from building
                    human.mesh.lookAt(human.mesh.position.clone().add(direction));
                    
                    // Set animation state
                    human.animationState = 'walking';
                } else {
                    // If collision detected, try to find a path
                    const perpendicular = new THREE.Vector3(-direction.z, 0, direction.x);
                    const sidePosition = human.mesh.position.clone().add(perpendicular.multiplyScalar(human.speed * 2));
                    
                    if (!checkCollision(human, sidePosition)) {
                        human.mesh.position.copy(sidePosition);
                    } else {
                        // Try the other direction
                        const otherSidePosition = human.mesh.position.clone().add(perpendicular.multiplyScalar(-human.speed * 2));
                        
                        if (!checkCollision(human, otherSidePosition)) {
                            human.mesh.position.copy(otherSidePosition);
                        } else {
                            // Try to find a safe direction
                            for (let i = 0; i < 8; i++) {
                                const angle = (i / 8) * Math.PI * 2;
                                const testDirection = new THREE.Vector3(Math.cos(angle), 0, Math.sin(angle));
                                const testPosition = human.mesh.position.clone().add(testDirection.multiplyScalar(human.speed * 2));
                                
                                if (!checkCollision(human, testPosition)) {
                                    human.mesh.position.copy(testPosition);
                                    break;
                                }
                            }
                        }
                    }
                }
            } else {
                // Exited building
                human.state = 'wandering';
                human.insideBuilding = null;
                human.buildingExitTimer = 0;
                
                // Remove from building occupants/workers
                if (human.targetBuilding) {
                    if (human.targetBuilding.type === 'house' && human.targetBuilding.data.occupants) {
                        const index = human.targetBuilding.data.occupants.indexOf(human);
                        if (index !== -1) {
                            human.targetBuilding.data.occupants.splice(index, 1);
                        }
                    } else if (human.targetBuilding.type === 'farm' && human.targetBuilding.data.workers) {
                        const index = human.targetBuilding.data.workers.indexOf(human);
                        if (index !== -1) {
                            human.targetBuilding.data.workers.splice(index, 1);
                        }
                    } else if (human.targetBuilding.type === 'pool' && human.targetBuilding.data.swimmers) {
                        const index = human.targetBuilding.data.swimmers.indexOf(human);
                        if (index !== -1) {
                            human.targetBuilding.data.swimmers.splice(index, 1);
                        }
                    } else if (human.targetBuilding.type === 'luxury' && human.targetBuilding.data.occupants) {
                        const index = human.targetBuilding.data.occupants.indexOf(human);
                        if (index !== -1) {
                            human.targetBuilding.data.occupants.splice(index, 1);
                        }
                    }
                    human.targetBuilding = null;
                }
                
                // Set animation state
                human.animationState = 'idle';
                
                // Show exiting speech
                if (aiSpeech) {
                    let phrase = "Leaving... 🚪";
                    if (human.insideBuilding) {
                        if (human.insideBuilding.type === 'house') {
                            phrase = "Leaving home! 👋";
                        } else if (human.insideBuilding.type === 'pool') {
                            phrase = "Done swimming! 👙";
                        } else if (human.insideBuilding.type === 'farm') {
                            phrase = "Done working! 🚜";
                        } else if (human.insideBuilding.type === 'luxury') {
                            phrase = "Leaving luxury house! 👋";
                        }
                    }
                    showSpeech(human, phrase, 2000);
                }
            }
        }
        
        function checkCollision(human, newPosition) {
            // Create a raycaster to check for collisions
            const raycaster = new THREE.Raycaster();
            const direction = new THREE.Vector3(0, -1, 0); // Downward ray
            raycaster.set(newPosition, direction);
            
            // Check for intersections with objects
            const intersects = raycaster.intersectObjects(objects, true);
            
            // If there's an intersection close to the ground, there's a collision
            for (const intersect of intersects) {
                if (intersect.distance < 1.7) { // Human height is about 1.7
                    return true; // Collision detected
                }
            }
            
            // Check for collisions with maze walls
            if (currentBiome === 'maze') {
                for (const wall of mazeWalls) {
                    const distance = newPosition.distanceTo(wall.position);
                    if (distance < 2.5) { // Wall size is 5, so half is 2.5
                        return true; // Collision with maze wall
                    }
                }
            }
            
            // Check for collisions with luxury houses
            if (currentBiome === 'luxury') {
                if (window.luxuryHouses) {
                    for (const house of window.luxuryHouses) {
                        const distance = newPosition.distanceTo(house.position);
                        if (distance < 7.0) { // House size is 12, so half is 6
                            return true; // Collision with luxury house
                        }
                    }
                }
            }
            
            // Check for collisions with other humans
            for (const otherHuman of aiHumans) {
                if (otherHuman !== human && !otherHuman.insideBuilding) {
                    const distance = newPosition.distanceTo(otherHuman.mesh.position);
                    if (distance < 1.0) { // Minimum distance between humans
                        return true; // Collision with another human
                    }
                }
            }
            
            // Check for collisions with buildings
            if (currentBiome === 'town') {
                // Check houses
                if (window.townHouses) {
                    for (const house of window.townHouses) {
                        const distance = newPosition.distanceTo(house.position);
                        if (distance < 5.0) { // House size is 8, so half is 4
                            return true; // Collision with house
                        }
                    }
                }
                
                // Check pools
                if (window.townPools) {
                    for (const pool of window.townPools) {
                        const distance = newPosition.distanceTo(pool.position);
                        if (distance < 6.0) { // Pool size is 10, so half is 5
                            return true; // Collision with pool
                        }
                    }
                }
                
                // Check farms
                if (window.townFarms) {
                    for (const farm of window.townFarms) {
                        const distance = newPosition.distanceTo(farm.position);
                        if (distance < 11.0) { // Farm size is 20, so half is 10
                            return true; // Collision with farm
                        }
                    }
                }
            }
            
            return false; // No collision
        }
        
        function updateAnimations(human) {
            // Apply animations based on animation state
            switch(human.animationState) {
                case 'idle':
                    // Slight breathing animation
                    const breathScale = 1 + Math.sin(human.animationTimer * 0.05) * 0.01;
                    human.body.scale.y = breathScale;
                    
                    // Slight head movement
                    human.head.rotation.y = Math.sin(human.animationTimer * 0.03) * 0.1;
                    
                    // Arm swing
                    human.leftArm.rotation.z = Math.PI / 6 + Math.sin(human.animationTimer * 0.05) * 0.05;
                    human.rightArm.rotation.z = -Math.PI / 6 + Math.sin(human.animationTimer * 0.05) * 0.05;
                    break;
                    
                case 'walking':
                    // Walking animation
                    const walkCycle = human.animationTimer * 0.2;
                    
                    // Body bob
                    human.mesh.position.y = Math.abs(Math.sin(walkCycle)) * 0.1;
                    
                    // Arm swing
                    human.leftArm.rotation.z = Math.PI / 6 + Math.sin(walkCycle) * 0.5;
                    human.rightArm.rotation.z = -Math.PI / 6 - Math.sin(walkCycle) * 0.5;
                    
                    // Leg movement
                    human.leftLeg.rotation.x = Math.sin(walkCycle) * 0.3;
                    human.rightLeg.rotation.x = -Math.sin(walkCycle) * 0.3;
                    break;
                    
                case 'running':
                    // Running animation
                    const runCycle = human.animationTimer * 0.3;
                    
                    // Body bob (more pronounced)
                    human.mesh.position.y = Math.abs(Math.sin(runCycle)) * 0.2;
                    
                    // Body lean forward
                    human.mesh.rotation.x = -0.1;
                    
                    // Arm swing (more pronounced)
                    human.leftArm.rotation.z = Math.PI / 4 + Math.sin(runCycle) * 0.7;
                    human.rightArm.rotation.z = -Math.PI / 4 - Math.sin(runCycle) * 0.7;
                    
                    // Leg movement (more pronounced)
                    human.leftLeg.rotation.x = Math.sin(runCycle) * 0.5;
                    human.rightLeg.rotation.x = -Math.sin(runCycle) * 0.5;
                    break;
                    
                case 'interacting':
                    // Interaction animation
                    const interactCycle = human.animationTimer * 0.1;
                    
                    // Nodding head
                    human.head.rotation.x = Math.sin(interactCycle) * 0.2;
                    
                    // Arm gestures
                    human.leftArm.rotation.z = Math.PI / 6 + Math.sin(interactCycle) * 0.3;
                    human.rightArm.rotation.z = -Math.PI / 6 - Math.sin(interactCycle) * 0.3;
                    break;
            }
        }
        
        function showEmotion(human, emotion, duration) {
            // Set current emotion
            human.currentEmotion = emotion;
            
            // Show emotion indicator
            human.emotionElement.textContent = emotion.emoji;
            human.emotionElement.style.display = 'block';
            human.emotionElement.style.color = `#${emotion.color.toString(16).padStart(6, '0')}`;
            
            // Set emotion timer
            human.emotionTimer = duration / 50; // Convert to frames (assuming 50 FPS)
        }
        
        function showSpeech(human, text, duration) {
            // Set speech text
            human.speechBubbleElement.textContent = text;
            
            // Show speech bubble
            human.speechBubbleElement.style.display = 'block';
            
            // Set speech timer
            human.speechTimer = duration / 50; // Convert to frames (assuming 50 FPS)
        }
        
        function pickupGun(human, gun) {
            // Attach gun to human's hand
            human.heldGun = gun;
            gun.isHeld = true;
            gun.holder = human;
            
            // Remove physics from gun
            if (isPhysicsEnabled) {
                world.remove(gun.body);
            }
            
            // Position gun in hand
            updateHeldGun(human);
            
            // Show happy emotion
            showEmotion(human, emotions[0], 2000); // Happy
            
            // Show speech
            if (aiSpeech) {
                const phrases = [
                    "Got a gun! 🔫",
                    "Now I'm protected! 🛡️",
                    "This will come in handy! 🔧",
                    "Feel safer now! 😌",
                    "Watch out, world! 👀"
                ];
                const phrase = phrases[Math.floor(Math.random() * phrases.length)];
                showSpeech(human, phrase, 2000);
            }
        }
        
        function updateHeldGun(human) {
            if (!human.heldGun) return;
            
            // Position gun in right hand
            const gunPosition = new THREE.Vector3(0.5, 1.2, 0);
            gunPosition.applyMatrix4(human.mesh.matrixWorld);
            human.heldGun.mesh.position.copy(gunPosition);
            
            // Rotate gun to point forward
            human.heldGun.mesh.rotation.copy(human.mesh.rotation);
            human.heldGun.mesh.rotateY(Math.PI / 2); // Adjust orientation
        }
        
        function shootGun(shooter, target) {
            if (!shooter.heldGun || shooter.heldGun.ammo <= 0) return;
            
            // Decrease ammo
            shooter.heldGun.ammo--;
            
            // Calculate bullet direction with some inaccuracy based on shooter's accuracy
            const direction = new THREE.Vector3();
            direction.subVectors(target.mesh.position, shooter.mesh.position);
            direction.y += 0.5; // Aim at center mass
            
            // Add inaccuracy
            const inaccuracy = (1 - shooter.accuracy) * 0.2;
            direction.x += (Math.random() - 0.5) * inaccuracy;
            direction.y += (Math.random() - 0.5) * inaccuracy;
            direction.z += (Math.random() - 0.5) * inaccuracy;
            
            direction.normalize();
            
            // Create bullet
            const bulletGeometry = new THREE.SphereGeometry(0.05, 8, 8);
            const bulletMaterial = new THREE.MeshPhongMaterial({ color: 0xFFFF00 });
            const bulletMesh = new THREE.Mesh(bulletGeometry, bulletMaterial);
            
            // Position bullet at gun barrel
            const bulletPosition = new THREE.Vector3(0.75, 1.2, 0);
            bulletPosition.applyMatrix4(shooter.mesh.matrixWorld);
            bulletMesh.position.copy(bulletPosition);
            
            scene.add(bulletMesh);
            
            // Create physics body for bullet
            const bulletShape = new CANNON.Sphere(0.05);
            const bulletBody = new CANNON.Body({
                mass: 0.01, // Very light
                shape: bulletShape,
                position: new CANNON.Vec3(
                    bulletPosition.x,
                    bulletPosition.y,
                    bulletPosition.z
                )
            });
            
            // Set bullet velocity
            const bulletSpeed = 30;
            bulletBody.velocity.set(
                direction.x * bulletSpeed,
                direction.y * bulletSpeed,
                direction.z * bulletSpeed
            );
            
            if (isPhysicsEnabled) {
                world.add(bulletBody);
            }
            
            // Create bullet object
            const bullet = {
                mesh: bulletMesh,
                body: bulletBody,
                shooter: shooter,
                lifetime: 60 // Frames before bullet disappears
            };
            
            bullets.push(bullet);
            
            // Add muzzle flash effect
            const flashGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const flashMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xFFFFAA,
                transparent: true
            });
            const flash = new THREE.Mesh(flashGeometry, flashMaterial);
            flash.position.copy(bulletPosition);
            scene.add(flash);
            
            // Remove flash after a short time
            setTimeout(() => {
                scene.remove(flash);
            }, 100);
            
            // Add shooting animation
            shooter.rightArm.rotation.z = -Math.PI / 3;
            setTimeout(() => {
                if (shooter.rightArm) {
                    shooter.rightArm.rotation.z = -Math.PI / 6;
                }
            }, 100);
        }
        
        function updateBullets() {
            // Update bullet positions
            bullets.forEach((bullet, index) => {
                // Decrease lifetime
                bullet.lifetime--;
                
                // Remove bullet if lifetime is expired
                if (bullet.lifetime <= 0) {
                    scene.remove(bullet.mesh);
                    if (isPhysicsEnabled) {
                        world.remove(bullet.body);
                    }
                    bullets.splice(index, 1);
                    return;
                }
                
                // Update bullet position from physics
                if (isPhysicsEnabled) {
                    bullet.mesh.position.copy(bullet.body.position);
                } else {
                    // Move bullet manually if physics is disabled
                    const velocity = bullet.body.velocity.clone();
                    velocity.scale(1/60); // Assuming 60 FPS
                    bullet.mesh.position.add(velocity);
                }
                
                // Check for collisions with humans
                aiHumans.forEach(human => {
                    if (human !== bullet.shooter && human.health > 0 && !human.insideBuilding) {
                        const distance = bullet.mesh.position.distanceTo(human.mesh.position);
                        if (distance < 0.5) { // Hit!
                            // Apply damage (20 points)
                            human.health -= 20;
                            
                            // Update health bar
                            updateHealthBar(human);
                            
                            // Show pain emotion
                            showEmotion(human, emotions[1], 2000); // Sad/pain
                            
                            // Show pain speech
                            if (aiSpeech) {
                                const phrases = [
                                    "Ouch! That hurts! 😫",
                                    "I've been shot! 💉",
                                    "Medic! 🚑",
                                    "I'm hit! 🔫",
                                    "This is bad! 😰"
                                ];
                                const phrase = phrases[Math.floor(Math.random() * phrases.length)];
                                showSpeech(human, phrase, 2000);
                            }
                            
                            // Apply knockback
                            if (isPhysicsEnabled) {
                                const knockbackDirection = new THREE.Vector3();
                                knockbackDirection.subVectors(human.mesh.position, bullet.mesh.position).normalize();
                                
                                human.body.applyImpulse(
                                    new CANNON.Vec3(
                                        knockbackDirection.x * 5,
                                        2, // Upward force
                                        knockbackDirection.z * 5
                                    ),
                                    human.body.position
                                );
                            }
                            
                            // Remove bullet
                            scene.remove(bullet.mesh);
                            if (isPhysicsEnabled) {
                                world.remove(bullet.body);
                            }
                            bullets.splice(index, 1);
                        }
                    }
                });
                
                // Check for collisions with ragdolls
                ragdolls.forEach(ragdoll => {
                    ragdoll.parts.forEach(part => {
                        const distance = bullet.mesh.position.distanceTo(part.mesh.position);
                        if (distance < 0.3) { // Hit!
                            // Apply impulse to ragdoll part
                            if (isPhysicsEnabled) {
                                const impulseDirection = new THREE.Vector3();
                                impulseDirection.subVectors(part.mesh.position, bullet.mesh.position).normalize();
                                
                                part.body.applyImpulse(
                                    new CANNON.Vec3(
                                        impulseDirection.x * 2,
                                        1, // Upward force
                                        impulseDirection.z * 2
                                    ),
                                    part.body.position
                                );
                            }
                            
                            // Remove bullet
                            scene.remove(bullet.mesh);
                            if (isPhysicsEnabled) {
                                world.remove(bullet.body);
                            }
                            bullets.splice(index, 1);
                        }
                    });
                });
                
                // Check for collisions with ground
                if (bullet.mesh.position.y < -1.9) {
                    // Create bullet hole effect
                    const holeGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.01, 16);
                    const holeMaterial = new THREE.MeshPhongMaterial({ color: 0x222222 });
                    const hole = new THREE.Mesh(holeGeometry, holeMaterial);
                    hole.position.copy(bullet.mesh.position);
                    hole.position.y = -1.95;
                    hole.rotation.x = Math.PI / 2;
                    scene.add(hole);
                    
                    // Remove bullet
                    scene.remove(bullet.mesh);
                    if (isPhysicsEnabled) {
                        world.remove(bullet.body);
                    }
                    bullets.splice(index, 1);
                }
            });
        }
        
        function updateHealthBar(human) {
            // Calculate health percentage
            const healthPercent = Math.max(0, human.health / human.maxHealth);
            
            // Update health bar width
            human.healthBar.style.width = `${healthPercent * 100}%`;
            
            // Update health bar color based on health level
            if (healthPercent > 0.6) {
                human.healthBar.style.backgroundColor = '#ff0000'; // Red
            } else if (healthPercent > 0.3) {
                human.healthBar.style.backgroundColor = '#ff0000'; // Red
            } else {
                human.healthBar.style.backgroundColor = '#ff0000'; // Red
            }
            
            // Position health bar above human
            const humanPosition = human.mesh.position.clone();
            humanPosition.y += 2.2; // Above head
            humanPosition.project(camera);
            
            const x = (humanPosition.x * 0.5 + 0.5) * window.innerWidth;
            const y = (-humanPosition.y * 0.5 + 0.5) * window.innerHeight;
            
            human.healthBarElement.style.left = `${x}px`;
            human.healthBarElement.style.top = `${y}px`;
            
            // Position interaction indicator
            human.interactionElement.style.left = `${x}px`;
            human.interactionElement.style.top = `${y - 15}px`;
            
            // Position speech bubble
            human.speechBubbleElement.style.left = `${x - 75}px`;
            human.speechBubbleElement.style.top = `${y - 40}px`;
            
            // Position emotion indicator
            human.emotionElement.style.left = `${x}px`;
            human.emotionElement.style.top = `${y - 30}px`;
            
            // Set interaction indicator color based on relationship
            if (human.targetHuman) {
                const relationship = human.relationships[human.targetHuman.mesh.uuid] || 0;
                if (relationship > 0.5) {
                    human.interactionElement.className = 'interaction-indicator love-indicator';
                } else {
                    human.interactionElement.className = 'interaction-indicator hate-indicator';
                }
            }
        }
        
        function updateRagdolls() {
            ragdolls.forEach(ragdoll => {
                // Update ragdoll parts based on physics
                ragdoll.parts.forEach(part => {
                    if (isPhysicsEnabled) {
                        part.mesh.position.copy(part.body.position);
                        part.mesh.quaternion.copy(part.body.quaternion);
                    }
                });
            });
        }
        
        function updateWaterSystem() {
            if (isRaining) {
                // Update rain particles and accumulate water
                const positions = rainParticles.geometry.attributes.position.array;
                
                for (let i = 1; i < positions.length; i += 3) {
                    positions[i] -= 0.3 * rainIntensity; // Move down faster with intensity
                    
                    // Reset particle if it goes below ground
                    if (positions[i] < -2) {
                        // Add water to grid at this position
                        const gridX = Math.floor(positions[i - 1] / waterGridSize);
                        const gridZ = Math.floor(positions[i + 1] / waterGridSize);
                        const waterKey = `${gridX},${gridZ}`;
                        
                        // Increase water level in this grid cell
                        if (waterGrid[waterKey] !== undefined) {
                            waterGrid[waterKey] += 0.001 * rainIntensity;
                            
                            // Cap water level at maximum
                            if (waterGrid[waterKey] > 1) {
                                waterGrid[waterKey] = 1;
                            }
                            
                            // Spread water to adjacent cells if this cell is full
                            if (waterGrid[waterKey] >= 1) {
                                spreadWater(gridX, gridZ);
                            }
                        }
                        
                        // Create wet spot on the ground
                        createWetSpot(
                            new THREE.Vector3(positions[i - 1], -1.99, positions[i + 1])
                        );
                        
                        // Reset particle position
                        positions[i] = 50;
                        positions[i - 1] = (Math.random() - 0.5) * 150; // x - Increased land size
                        positions[i + 1] = (Math.random() - 0.5) * 150; // z - Increased land size
                    }
                }
                
                rainParticles.geometry.attributes.position.needsUpdate = true;
                
                // Update water meshes
                updateWaterMeshes();
                
                // Calculate overall water level
                calculateWaterLevel();
                
                // Make grass look wet when raining
                if (currentBiome === 'forest' || currentBiome === 'jungle') {
                    updateGrassWetness();
                }
            }
        }
        
        function createWetSpot(position) {
            // Create a wet spot on the ground at the given position
            const wetSpotGeometry = new THREE.CircleGeometry(0.2, 16);
            const wetSpotMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x1E90FF, // Blue color for water
                transparent: true,
                opacity: 0.6
            });
            
            const wetSpot = new THREE.Mesh(wetSpotGeometry, wetSpotMaterial);
            wetSpot.rotation.x = -Math.PI / 2; // Lay flat on the ground
            wetSpot.position.copy(position);
            
            scene.add(wetSpot);
            wetSpots.push(wetSpot);
            
            // Set a timer to remove the wet spot when rain stops
            wetSpot.userData = {
                creationTime: Date.now(),
                dryingTime: 10000 + Math.random() * 10000 // 10-20 seconds to dry
            };
        }
        
        function updateGrassWetness() {
            // Make grass look wet when it's raining
            grassBlades.forEach(blade => {
                // Make grass darker and more reflective when wet
                blade.material.color.setHex(0x2a5f2a); // Darker green
                blade.material.emissive = new THREE.Color(0x001100); // Slight emissive for wet look
                blade.material.emissiveIntensity = 0.2;
                blade.material.needsUpdate = true;
            });
        }
        
        function spreadWater(fromX, fromZ) {
            // Spread water to adjacent cells
            const adjacentCells = [
                [fromX - 1, fromZ],
                [fromX + 1, fromZ],
                [fromX, fromZ - 1],
                [fromX, fromZ + 1]
            ];
            
            adjacentCells.forEach(([x, z]) => {
                const key = `${x},${z}`;
                if (waterGrid[key] !== undefined) {
                    // Transfer some water to adjacent cell
                    const transferAmount = 0.05;
                    waterGrid[fromX + ',' + fromZ] -= transferAmount;
                    waterGrid[key] += transferAmount;
                    
                    // Ensure water level doesn't go below 0
                    if (waterGrid[fromX + ',' + fromZ] < 0) {
                        waterGrid[fromX + ',' + fromZ] = 0;
                    }
                    
                    // Cap water level at maximum
                    if (waterGrid[key] > 1) {
                        waterGrid[key] = 1;
                    }
                }
            });
        }
        
        function updateWaterMeshes() {
            // Remove existing water meshes
            waterMeshes.forEach(water => {
                scene.remove(water);
            });
            waterMeshes = [];
            
            // Create new water meshes based on water grid
            Object.keys(waterGrid).forEach(key => {
                const [x, z] = key.split(',').map(Number);
                const waterLevel = waterGrid[key];
                
                if (waterLevel > 0.05) { // Only show water if level is significant
                    const waterGeometry = new THREE.PlaneGeometry(waterGridSize, waterGridSize);
                    const waterMaterial = new THREE.MeshPhongMaterial({
                        color: 0x1E90FF,
                        transparent: true,
                        opacity: Math.min(waterLevel * 0.8, 0.8),
                        side: THREE.DoubleSide
                    });
                    
                    const waterMesh = new THREE.Mesh(waterGeometry, waterMaterial);
                    waterMesh.rotation.x = Math.PI / 2;
                    waterMesh.position.set(
                        x * waterGridSize,
                        -1.99 + waterLevel * 0.5, // Raise water based on depth
                        z * waterGridSize
                    );
                    
                    scene.add(waterMesh);
                    waterMeshes.push(waterMesh);
                }
            });
        }
        
        function calculateWaterLevel() {
            // Calculate overall water level as percentage
            let totalWater = 0;
            let totalCells = 0;
            
            Object.values(waterGrid).forEach(level => {
                totalWater += level;
                totalCells++;
            });
            
            waterLevel = (totalWater / totalCells) * 100;
            updateWaterLevelDisplay();
            
            // Check for flood warning
            if (waterLevel > 70 && !floodWarningShown) {
                document.getElementById('floodWarning').style.display = 'block';
                floodWarningShown = true;
            } else if (waterLevel <= 70 && floodWarningShown) {
                document.getElementById('floodWarning').style.display = 'none';
                floodWarningShown = false;
            }
        }
        
        function updateWaterLevelDisplay() {
            document.getElementById('waterLevel').textContent = Math.round(waterLevel);
        }
        
        function makeEverythingWet() {
            // Store original materials and make them look wet
            objects.forEach(obj => {
                if (obj.material && obj.material.type === 'MeshPhongMaterial') {
                    // Store original material properties
                    wetMaterials.push({
                        mesh: obj,
                        originalShininess: obj.material.shininess,
                        originalSpecular: obj.material.specular ? obj.material.specular.getHex() : 0x111111
                    });
                    
                    // Make material look wet (more reflective)
                    obj.material.shininess = 100;
                    obj.material.specular = new THREE.Color(0x555555);
                    obj.material.needsUpdate = true;
                }
            });
        }
        
        function dryEverything() {
            // Restore original materials
            wetMaterials.forEach(item => {
                if (item.mesh.material) {
                    item.mesh.material.shininess = item.originalShininess;
                    item.mesh.material.specular = new THREE.Color(item.originalSpecular);
                    item.mesh.material.needsUpdate = true;
                }
            });
            
            // Restore grass color
            grassBlades.forEach(blade => {
                blade.material.color.setHex(currentBiome === 'forest' ? 0x3a7e3a : 0x2d5a2d);
                blade.material.emissive = new THREE.Color(0x000000);
                blade.material.emissiveIntensity = 0;
                blade.material.needsUpdate = true;
            });
            
            wetMaterials = [];
            
            // Remove wet spots when rain stops
            wetSpots.forEach(wetSpot => {
                scene.remove(wetSpot);
            });
            wetSpots = [];
        }
        
        function addSnowToGround(position) {
            // Create a small snow pile at the given position
            const snowGeometry = new THREE.CylinderGeometry(0.3, 0.4, 0.1, 16);
            const snowMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff });
            const snowPile = new THREE.Mesh(snowGeometry, snowMaterial);
            
            snowPile.position.copy(position);
            snowPile.position.y = -1.95; // Just above ground
            
            scene.add(snowPile);
            snowOnGround.push(snowPile);
        }
        
        function removeSnowFromGround() {
            // Remove all snow from the ground
            snowOnGround.forEach(snow => {
                scene.remove(snow);
            });
            snowOnGround = [];
        }
        
        function updatePhysics() {
            if (!isPhysicsEnabled) return;
            
            // Step the physics world with optimized settings
            world.step(1/60);
            
            // Update mesh positions based on physics bodies
            physicsObjects.forEach(body => {
                if (body.mesh) {
                    body.mesh.position.copy(body.position);
                    body.mesh.quaternion.copy(body.quaternion);
                }
            });
            
            // Update AI humans
            aiHumans.forEach(human => {
                if (!human.insideBuilding) {
                    human.mesh.position.copy(human.body.position);
                    human.mesh.position.y -= 0.85; // Adjust for body center
                    human.mesh.quaternion.copy(human.body.quaternion);
                }
            });
            
            // Update guns
            guns.forEach(gun => {
                if (!gun.isHeld) {
                    gun.mesh.position.copy(gun.body.position);
                    gun.mesh.quaternion.copy(gun.body.quaternion);
                }
            });
            
            // Update bullets
            bullets.forEach(bullet => {
                bullet.mesh.position.copy(bullet.body.position);
                bullet.mesh.quaternion.copy(bullet.body.quaternion);
            });
            
            // Update ragdolls
            ragdolls.forEach(ragdoll => {
                ragdoll.parts.forEach(part => {
                    part.mesh.position.copy(part.body.position);
                    part.mesh.quaternion.copy(part.body.quaternion);
                });
            });
            
            // Update player body if in first person mode
            if (isFirstPersonMode && playerBody) {
                camera.position.x = playerBody.position.x;
                camera.position.y = playerBody.position.y + player.height / 2;
                camera.position.z = playerBody.position.z;
            }
        }
        
        function updateWeather() {
            if (isRaining) {
                // Update water system
                updateWaterSystem();
            }
            
            if (isSnowing) {
                // Update snow particles
                const positions = snowParticles.geometry.attributes.position.array;
                for (let i = 1; i < positions.length; i += 3) {
                    positions[i] -= 0.05; // Move down slower than rain
                    
                    // Add some horizontal movement for a more natural snow effect
                    positions[i - 1] += Math.sin(Date.now() * 0.001 + i) * 0.01;
                    
                    // Reset particle if it goes below ground
                    if (positions[i] < -2) {
                        // Add snow to ground at this position
                        addSnowToGround(new THREE.Vector3(
                            positions[i - 1],
                            positions[i],
                            positions[i + 1]
                        ));
                        
                        positions[i] = 50;
                        positions[i - 1] = (Math.random() - 0.5) * 150; // x - Increased land size
                        positions[i + 1] = (Math.random() - 0.5) * 150; // z - Increased land size
                    }
                }
                snowParticles.geometry.attributes.position.needsUpdate = true;
            }
        }
        
        function updateDayNightCycle() {
            if (!isDayNightCycle) return;
            
            // Update time
            currentTime += dayNightSpeed;
            if (currentTime >= 24) {
                currentTime -= 24;
            }
            
            // Calculate sun position based on time
            const sunAngle = (currentTime / 24) * Math.PI * 2 - Math.PI / 2;
            const sunHeight = Math.sin(sunAngle);
            const sunDistance = 30;
            
            sun.position.x = Math.cos(sunAngle) * sunDistance;
            sun.position.y = sunHeight * sunDistance;
            
            // Calculate moon position (opposite to sun)
            const moonAngle = sunAngle + Math.PI;
            const moonHeight = Math.sin(moonAngle);
            const moonDistance = 30;
            
            moon.position.x = Math.cos(moonAngle) * moonDistance;
            moon.position.y = moonHeight * moonDistance;
            
            // Update moon light position
            const moonLight = scene.children.find(child => child.type === 'DirectionalLight' && child !== sun);
            if (moonLight) {
                moonLight.position.copy(moon.position);
            }
            
            // Update lighting based on time of day
            let intensity, ambientIntensity, skyColor;
            
            if (currentTime >= 6 && currentTime < 18) {
                // Daytime
                intensity = 1;
                ambientIntensity = 0.5;
                skyColor = new THREE.Color(0x87CEEB); // Sky blue
                sun.visible = true;
                moon.visible = false;
                stars.visible = false;
            } else if (currentTime >= 18 && currentTime < 20) {
                // Sunset
                intensity = 0.5;
                ambientIntensity = 0.3;
                skyColor = new THREE.Color(0xFF7F50); // Coral
                sun.visible = true;
                moon.visible = false;
                stars.visible = false;
            } else if (currentTime >= 20 || currentTime < 5) {
                // Night
                intensity = 0.1;
                ambientIntensity = 0.1;
                skyColor = new THREE.Color(0x000033); // Dark blue
                sun.visible = false;
                moon.visible = true;
                stars.visible = true;
            } else {
                // Sunrise
                intensity = 0.5;
                ambientIntensity = 0.3;
                skyColor = new THREE.Color(0xFF7F50); // Coral
                sun.visible = true;
                moon.visible = false;
                stars.visible = false;
            }
            
            sun.intensity = intensity;
            ambientLight.intensity = ambientIntensity;
            scene.background = skyColor;
            
            // Update time display
            const hours = Math.floor(currentTime);
            const minutes = Math.floor((currentTime - hours) * 60);
            document.getElementById('currentTime').textContent = 
                `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
        }
        
        function updateStats() {
            document.getElementById('humanCount').textContent = aiHumans.length;
            document.getElementById('gunCount').textContent = guns.length;
            document.getElementById('ragdollCount').textContent = ragdolls.length;
            
            const armedCount = aiHumans.filter(human => human.heldGun !== null).length;
            document.getElementById('armedCount').textContent = armedCount;
        }
        
        function updateModeDisplay() {
            let mode = "Normal";
            
            if (isPhysicsEnabled) mode = "Physics";
            if (isRaining) mode = "Rain";
            if (isSnowing) mode = "Snow";
            if (isDayNightCycle) mode += " + Day/Night";
            if (isFirstPersonMode) mode += " + First Person";
            
            document.getElementById('currentMode').textContent = mode;
        }
        
        function updatePerformance() {
            // Calculate FPS
            frameCount++;
            const currentTime = performance.now();
            
            if (currentTime >= fpsUpdateTime + 1000) {
                fps = Math.round((frameCount * 1000) / (currentTime - fpsUpdateTime));
                document.getElementById('fps').textContent = fps;
                
                frameCount = 0;
                fpsUpdateTime = currentTime;
            }
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            // Update recording canvas size if it exists
            if (recordingCanvas) {
                recordingCanvas.width = window.innerWidth;
                recordingCanvas.height = window.innerHeight;
            }
        }
        
        function onMouseDown(event) {
            // Calculate mouse position in normalized device coordinates
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            // Update the picking ray with the camera and mouse position
            raycaster.setFromCamera(mouse, camera);
            
            // Check for ragdoll intersections first
            let ragdollIntersected = false;
            for (let i = 0; i < ragdolls.length; i++) {
                const ragdoll = ragdolls[i];
                const ragdollIntersects = raycaster.intersectObjects(ragdoll.parts.map(p => p.mesh));
                
                if (ragdollIntersects.length > 0) {
                    ragdollIntersected = true;
                    
                    // Find the intersected part
                    const intersectedPart = ragdoll.parts.find(part => 
                        ragdollIntersects[0].object === part.mesh
                    );
                    
                    if (intersectedPart) {
                        isDragging = true;
                        draggedRagdollPart = intersectedPart;
                        controls.enabled = false; // Disable camera controls while dragging
                        
                        // Create a constraint for physics dragging
                        if (isPhysicsEnabled) {
                            // Create a point-to-point constraint
                            const pointInSpace = new CANNON.Vec3();
                            pointInSpace.copy(intersectedPart.body.position);
                            
                            dragConstraint = new CANNON.PointToPointConstraint(
                                intersectedPart.body,
                                new CANNON.Vec3(0, 0, 0), // Point on the body
                                new CANNON.Body({ mass: 0 }), // Static body
                                pointInSpace
                            );
                            
                            world.add(dragConstraint);
                        }
                        break; // Exit the loop once we found a ragdoll part
                    }
                }
            }
            
            // If no ragdoll was intersected, check for regular objects
            if (!ragdollIntersected) {
                const intersects = raycaster.intersectObjects(objects, true);
                
                if (intersects.length > 0) {
                    // Find the draggable parent
                    let object = intersects[0].object;
                    while (object.parent && !object.userData.draggable) {
                        object = object.parent;
                    }
                    
                    if (object.userData.draggable) {
                        isDragging = true;
                        dragObject = object;
                        controls.enabled = false; // Disable camera controls while dragging
                        
                        // Create a constraint for physics dragging
                        if (isPhysicsEnabled) {
                            const physicsBody = physicsObjects.find(body => body.mesh === object);
                            if (physicsBody) {
                                // Create a point-to-point constraint
                                const pointInSpace = new CANNON.Vec3();
                                pointInSpace.copy(physicsBody.position);
                                
                                dragConstraint = new CANNON.PointToPointConstraint(
                                    physicsBody,
                                    new CANNON.Vec3(0, 0, 0), // Point on the body
                                    new CANNON.Body({ mass: 0 }), // Static body
                                    pointInSpace
                                );
                                
                                world.add(dragConstraint);
                            }
                        }
                    }
                }
            }
        }
        
        function onMouseMove(event) {
            if (isDragging) {
                // Calculate mouse position in normalized device coordinates
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                
                // Update the picking ray with the camera and mouse position
                raycaster.setFromCamera(mouse, camera);
                
                // Calculate intersection with a plane at y=0
                const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
                const intersection = new THREE.Vector3();
                raycaster.ray.intersectPlane(plane, intersection);
                
                if (intersection) {
                    if (draggedRagdollPart) {
                        // Update ragdoll part position
                        draggedRagdollPart.mesh.position.x = intersection.x;
                        draggedRagdollPart.mesh.position.z = intersection.z;
                        
                        // Update physics constraint if it exists
                        if (dragConstraint) {
                            dragConstraint.pivotB.copy(intersection);
                        }
                    } else if (dragObject) {
                        // Update regular object position
                        dragObject.position.x = intersection.x;
                        dragObject.position.z = intersection.z;
                        
                        // Update physics constraint if it exists
                        if (dragConstraint) {
                            dragConstraint.pivotB.copy(intersection);
                        }
                    }
                }
            }
        }
        
        function onMouseUp(event) {
            if (isDragging) {
                isDragging = false;
                
                if (draggedRagdollPart) {
                    draggedRagdollPart = null;
                } else if (dragObject) {
                    dragObject = null;
                }
                
                controls.enabled = true; // Re-enable camera controls
                
                // Remove physics constraint
                if (dragConstraint) {
                    world.remove(dragConstraint);
                    dragConstraint = null;
                }
            } else {
                // Handle regular click
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                
                // Update the picking ray with the camera and mouse position
                raycaster.setFromCamera(mouse, camera);
                
                // Calculate objects intersecting the picking ray
                const intersects = raycaster.intersectObjects(objects, true);
                
                if (intersects.length > 0) {
                    // Change color of the first intersected object
                    let object = intersects[0].object;
                    while (object.parent && !object.material) {
                        object = object.parent;
                    }
                    
                    if (object.material) {
                        object.material.color.setHex(Math.random() * 0xffffff);
                    }
                    
                    // Add a small animation
                    const originalScale = object.scale.clone();
                    object.scale.multiplyScalar(1.2);
                    
                    setTimeout(() => {
                        object.scale.copy(originalScale);
                    }, 300);
                    
                    // Apply impulse if physics is enabled
                    if (isPhysicsEnabled) {
                        let physicsBody = physicsObjects.find(body => body.mesh === object);
                        
                        // Check if it's part of an AI human
                        if (!physicsBody) {
                            const human = aiHumans.find(h => h.mesh === object || h.mesh.children.includes(object));
                            if (human && !human.insideBuilding) {
                                physicsBody = human.body;
                            }
                        }
                        
                        // Check if it's a gun
                        if (!physicsBody) {
                            const gun = guns.find(g => g.mesh === object || g.mesh.children.includes(object));
                            if (gun) {
                                physicsBody = gun.body;
                            }
                        }
                        
                        if (physicsBody) {
                            // Calculate impulse direction away from camera
                            const direction = new THREE.Vector3();
                            direction.subVectors(object.position, camera.position).normalize();
                            
                            // Apply impulse
                            physicsBody.applyImpulse(
                                new CANNON.Vec3(
                                    direction.x * 10,
                                    direction.y * 10 + 5, // Add some upward force
                                    direction.z * 10
                                ),
                                physicsBody.position
                            );
                        }
                    }
                }
            }
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            // Update physics
            updatePhysics();
            
            // Update weather
            updateWeather();
            
            // Update day/night cycle
            updateDayNightCycle();
            
            // Update clouds
            updateClouds();
            
            // Update AI humans
            updateAIHumans();
            
            // Update bullets
            updateBullets();
            
            // Update ragdolls
            updateRagdolls();
            
            // Update first person controls
            if (isFirstPersonMode) {
                updateFirstPersonControls();
            }
            
            // Update auto camera
            if (autoCameraEnabled) {
                updateAutoCamera();
            }
            
            // Update controls
            controls.update();
            
            // Render the scene
            renderer.render(scene, camera);
            
            // Update performance metrics
            updatePerformance();
        }
        
        // Initialize the scene when the page loads
        window.addEventListener('load', init);
    </script>
<script>
      (function () {
        if ('serviceWorker' in navigator) {
          window.addEventListener('load', function () {
            navigator.serviceWorker.register('/sw.js').catch(function(){});
          });
        }
      })();
    </script>
</body>
</html>
